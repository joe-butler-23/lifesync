'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var React = require('react');
var classNames = _interopDefault(require('classnames'));
var draftJs = require('draft-js');
var menuButton = require('@reach/menu-button');
require('@reach/menu-button/styles.css');
var linkify = _interopDefault(require('linkify-it'));
var memoizeOne = _interopDefault(require('memoize-one'));
var escapeStringRegexp = _interopDefault(require('escape-string-regexp'));
var Immutable = require('immutable');
var Immutable__default = _interopDefault(Immutable);
require('draft-js/dist/Draft.css');

/**
 * We will only put the dispatch function in this context
 * The dispatch value from useReducer never changes after it's first created
 * Which means the components which access the dispatch functions from this context
 * will never uncessarily rerender on other state changes not related to them
 */

const EditorContext = /*#__PURE__*/React.createContext({});

function debounce(fn, delay) {
  let setTimeoutHandle;
  return function (...args) {
    // if the function is called again, cancel the timeout and start over again
    clearTimeout(setTimeoutHandle);
    setTimeoutHandle = setTimeout(() => {
      fn.apply(null, args);
    }, delay);
  };
}

function CheckMark(props) {
  return React.createElement("svg", Object.assign({
    fill: "none",
    strokeLinecap: "round",
    strokeLinejoin: "round",
    strokeWidth: 2,
    viewBox: "0 0 24 24",
    stroke: "currentColor"
  }, props), React.createElement("path", {
    d: "M5 13l4 4L19 7"
  }));
}

function ArrowRight(props) {
  return React.createElement("svg", Object.assign({
    fill: "none",
    strokeLinecap: "round",
    strokeLinejoin: "round",
    strokeWidth: 2,
    viewBox: "0 0 24 24",
    stroke: "currentColor"
  }, props), React.createElement("path", {
    d: "M17 8l4 4m0 0l-4 4m4-4H3"
  }));
}

function ArrowLeft(props) {
  return React.createElement("svg", Object.assign({
    fill: "none",
    strokeLinecap: "round",
    strokeLinejoin: "round",
    strokeWidth: 2,
    viewBox: "0 0 24 24",
    stroke: "currentColor"
  }, props), React.createElement("path", {
    d: "M7 16l-4-4m0 0l4-4m-4 4h18"
  }));
}

function DotHorizontal(props) {
  return React.createElement("svg", Object.assign({
    fill: "none",
    strokeLinecap: "round",
    strokeLinejoin: "round",
    strokeWidth: 2,
    viewBox: "0 0 24 24",
    stroke: "currentColor"
  }, props), React.createElement("path", {
    d: "M5 12h.01M12 12h.01M19 12h.01M6 12a1 1 0 11-2 0 1 1 0 012 0zm7 0a1 1 0 11-2 0 1 1 0 012 0zm7 0a1 1 0 11-2 0 1 1 0 012 0z"
  }));
}

function Star(props) {
  return React.createElement("svg", Object.assign({
    fill: "none",
    strokeLinecap: "round",
    strokeLinejoin: "round",
    strokeWidth: 1,
    viewBox: "0 0 24 24",
    stroke: "currentColor"
  }, props), React.createElement("path", {
    d: "M11.049 2.927c.3-.921 1.603-.921 1.902 0l1.519 4.674a1 1 0 00.95.69h4.915c.969 0 1.371 1.24.588 1.81l-3.976 2.888a1 1 0 00-.363 1.118l1.518 4.674c.3.922-.755 1.688-1.538 1.118l-3.976-2.888a1 1 0 00-1.176 0l-3.976 2.888c-.783.57-1.838-.197-1.538-1.118l1.518-4.674a1 1 0 00-.363-1.118l-3.976-2.888c-.784-.57-.38-1.81.588-1.81h4.914a1 1 0 00.951-.69l1.519-4.674z"
  }));
}

var styles = {"menu-container":"menu_styles-module_menu-container__1H_0Q","menu-left-container":"menu_styles-module_menu-left-container__Ac7Ac","menu-right-container":"menu_styles-module_menu-right-container__2RbN3","menu-icon":"menu_styles-module_menu-icon__jECU2","menu-icon-large":"menu_styles-module_menu-icon-large__2BwF4","bookmarked":"menu_styles-module_bookmarked__2CFZk","not-bookmarked":"menu_styles-module_not-bookmarked__1YiMp","close-button":"menu_styles-module_close-button__B-GJS","slide-down":"menu_styles-module_slide-down__1ZJ7b"};

var buttonStyles = {"button":"button_styles-module_button__2KbPc","icon-button":"button_styles-module_icon-button__2ddnV"};

function MenuContainer({
  onExpandAllClick,
  onCollapseAllClick,
  onIndentClick,
  onOutdentClick,
  onToggleCompletionClick,
  isBookmarked,
  onBookmarkClick
}) {
  return React.createElement("div", {
    className: styles['menu-container']
  }, React.createElement("div", {
    className: styles['menu-left-container']
  }, React.createElement("button", {
    onMouseDown: e => {
      // tip: mousedown event occurs before onFocus and onClick. If we
      // stop the propagation event in mousedown, the onFocus and onClick
      // events are not triggered. This means the editor item never loses
      // focus. This helps prevent the on screen keyboard to not hide on
      // mobile devices
      e.stopPropagation();
      e.preventDefault();
      e.nativeEvent.stopImmediatePropagation();
      onToggleCompletionClick();
    },
    "aria-label": "Mark complete",
    className: classNames(buttonStyles['icon-button'], buttonStyles['button']),
    title: "Mark complete"
  }, React.createElement(CheckMark, {
    className: styles['menu-icon']
  })), '\u00A0', React.createElement("button", {
    onMouseDown: e => {
      // tip: mousedown event occurs before onFocus and onClick. If we
      // stop the propagation event in mousedown, the onFocus and onClick
      // events are not triggered. This means the editor item never loses
      // focus. This helps prevent the on screen keyboard to not hide on
      // mobile devices
      e.stopPropagation();
      e.preventDefault();
      e.nativeEvent.stopImmediatePropagation();
      onOutdentClick();
    },
    "aria-label": "Outdent",
    className: classNames(buttonStyles['icon-button'], buttonStyles['button']),
    title: "Outdent"
  }, React.createElement(ArrowLeft, {
    className: styles['menu-icon']
  })), React.createElement("button", {
    onMouseDown: e => {
      e.stopPropagation();
      e.preventDefault();
      e.nativeEvent.stopImmediatePropagation();
      onIndentClick();
    },
    "aria-label": "Indent",
    className: classNames(buttonStyles['icon-button'], buttonStyles['button']),
    title: "Indent"
  }, React.createElement(ArrowRight, {
    className: styles['menu-icon']
  }))), React.createElement("div", {
    className: styles['menu-right-container']
  }, React.createElement("button", {
    className: classNames(buttonStyles['icon-button'], buttonStyles['button']),
    style: {
      marginRight: '1rem'
    },
    onMouseDown: e => {
      e.stopPropagation();
      e.preventDefault();
      e.nativeEvent.stopImmediatePropagation();
      onBookmarkClick();
    },
    "aria-label": "Bookmark item",
    title: "Bookmark item",
    "data-bookmarked": isBookmarked
  }, React.createElement(Star, {
    className: classNames(styles['menu-icon-large'], {
      [styles.bookmarked]: isBookmarked,
      [styles['not-bookmarked']]: !isBookmarked
    })
  })), React.createElement(menuButton.Menu, null, () => React.createElement(React.Fragment, null, React.createElement(menuButton.MenuButton, null, React.createElement("button", {
    className: classNames(buttonStyles['icon-button'], buttonStyles['button']),
    "aria-label": "Show menu"
  }, React.createElement(DotHorizontal, {
    className: styles['menu-icon']
  }))), React.createElement(menuButton.MenuList, {
    className: styles['slide-down']
  }, React.createElement(menuButton.MenuItem, {
    onSelect: onExpandAllClick
  }, "Expand all"), React.createElement(menuButton.MenuItem, {
    onSelect: onCollapseAllClick
  }, "Collapse all"))))));
}

function Hashtag({
  children,
  handleSearchInputChange
}) {
  return React.createElement("button", {
    style: {
      textDecoration: 'underline',
      color: 'rgb(134, 140, 144)',
      cursor: 'pointer'
    },
    onClick: () => {
      if (children[0] && children[0].props && children[0].props.text && handleSearchInputChange) {
        handleSearchInputChange(children[0].props.text);
      }
    },
    "data-testid": "hashtag"
  }, children);
}

var Hashtag$1 = /*#__PURE__*/React.memo(Hashtag);

function SearchHighlight(props) {
  return React.createElement("span", {
    style: {
      background: 'rgb(255,230,153)'
    }
  }, props.children);
}

var styles$1 = {"link":"link_styles-module_link__3R12D"};

function Link(props) {
  const link = React.Children.map(props.children, child => child && child.props ? child.props.text : '').join('');
  return React.createElement("a", {
    href: link,
    onClick: () => window.open(link, '_blank'),
    className: styles$1.link
  }, props.children);
}

const linkifyInstance = /*#__PURE__*/linkify();
const HASHTAG_REGEX = /#[\w\u0590-\u05ff]+/g;

function findWithRegex(regex, contentBlock, callback) {
  const text = contentBlock.getText();
  let matchArr, start;

  while ((matchArr = regex.exec(text)) !== null) {
    start = matchArr.index;
    callback(start, start + matchArr[0].length);
  }
}

function hashtagStrategy(contentBlock, callback) {
  findWithRegex(HASHTAG_REGEX, contentBlock, callback);
}

function findLinkEntities(contentBlock, callback) {
  const links = linkifyInstance.match(contentBlock.getText());

  if (links) {
    links.forEach(link => callback(link.index, link.lastIndex));
  }
}

const createDecorators = /*#__PURE__*/memoizeOne((searchText = '') => {
  const regex = new RegExp(escapeStringRegexp(searchText), 'gi');
  return new draftJs.CompositeDecorator([{
    strategy: hashtagStrategy,
    component: Hashtag$1
  }, {
    strategy: (contentBlock, callback) => {
      if (searchText) {
        findWithRegex(regex, contentBlock, callback);
      }
    },
    component: SearchHighlight
  }, {
    strategy: findLinkEntities,
    component: Link
  }]);
});

function pluckGoodies(editorState) {
  const contentState = editorState.getCurrentContent();
  const selectionState = editorState.getSelection();
  const blockMap = contentState.getBlockMap();
  const anchorKey = selectionState.getAnchorKey();
  const anchorBlock = contentState.getBlockForKey(anchorKey);
  const focusKey = selectionState.getFocusKey();
  const focusBlock = contentState.getBlockForKey(focusKey);
  return {
    contentState,
    selectionState,
    blockMap,
    anchorKey,
    anchorBlock,
    focusKey,
    focusBlock
  };
}

const ROOT_KEY = 'root';
const BASE_POS = 100000;
const MAX_DEPTH = 1000;
// responsiveness still fill a little slow but if i reduce it further, there
// will be to much rerender of the whole editor

const SEARCH_DEBOUNCE = 250;

function getPosNum(pos) {
  return pos * BASE_POS;
}
function getPosInBetween(posStart, posEnd) {
  return Math.round((posStart + posEnd) / 2);
}
function getPosAfter(lastPos) {
  return lastPos + BASE_POS;
}

function getNewContentBlock(config) {
  return new draftJs.ContentBlock({
    key: draftJs.genKey(),
    type: 'unordered-list-item',
    text: '',
    depth: 0,
    ...config
  });
}
function getEmptyBlock() {
  return getNewContentBlock({
    text: ''
  });
}
function getRootBlock(rootId) {
  return getNewContentBlock({
    text: '',
    key: rootId
  });
}
function getEmptySlateState(rootId) {
  const firstItem = getEmptyBlock().set('depth', 1).set('data', Immutable__default.Map({
    parentId: rootId,
    pos: getPosNum(1)
  }));
  const rootBlock = getRootBlock(rootId); // we add 2 blocks in our empty slate because
  // if we add only the root block, draftjs will then allow editing of the
  // root block item.
  // That problem goes away when i set the zoomedInItemId as 'root'. Hmm.
  // But then there's no starting item to work with. Which is why we need
  // the second empty block

  const firstBlocks = [rootBlock, firstItem]; // // How to get started with a list item by default
  // // Which is what workflowy does
  // // Just call RichUtils.toggleBlockType with the empty state we create at
  // // the beginning with 'unordered-list-item'
  // RichUtils.toggleBlockType(EditorState.createEmpty(), "unordered-list-item")
  // );

  let emptySlate = draftJs.EditorState.createWithContent(draftJs.ContentState.createFromBlockArray(firstBlocks), createDecorators());
  emptySlate = draftJs.EditorState.forceSelection(emptySlate, draftJs.SelectionState.createEmpty(firstItem.getKey()));
  return emptySlate;
}

function calculateDepth(blockMap, blockKey, zoomedInItemId) {
  let depth = -1;
  const block = blockMap.get(blockKey);

  if (!block) {
    return depth;
  }

  let parentBlock = blockMap.get(block.getIn(['data', 'parentId']));

  while (parentBlock) {
    if (zoomedInItemId && parentBlock.getKey() === zoomedInItemId) {
      break;
    }

    depth += 1;
    parentBlock = blockMap.get(parentBlock.getIn(['data', 'parentId']));
  }

  return depth;
}

// Only use for one time operations like at the start of load, or while saving etc.
// We are using it currently to add hasChildren information to a block when we initialize
// the editor

function hasChildren(blockMap, blockKey) {
  return !!blockMap.find(b => !!(b && b.getIn(['data', 'parentId']) === blockKey));
}
function adjustHasChildren(blockMap, blockKey) {
  const block = blockMap.get(blockKey);
  return blockMap.set(blockKey, block.setIn(['data', 'hasChildren'], hasChildren(blockMap, blockKey)));
} // TODO: Is it a better idea to get all children, sortByPos, and then return the first block?
// right now, we are relying on the fact that draft-js blocks are sorted by the order they appear in

function getFirstChild(blockMap, blockKey) {
  return blockMap.find(b => !!(b && b.getIn(['data', 'parentId']) === blockKey));
}
function getChildren(blockMap, blockKey) {
  return blockMap.filter(b => !!(b && b.getIn(['data', 'parentId']) === blockKey));
}
function getNextSibling(blockMap, blockKey) {
  const block = blockMap.get(blockKey);
  const parentId = block.getIn(['data', 'parentId']);
  return blockMap.filter(b => !!(b && b.getIn(['data', 'parentId']) === parentId)).find(b => !!(b && b.getIn(['data', 'pos']) > block.getIn(['data', 'pos'])));
}
function getPreviousSibling(blockMap, blockKey) {
  const block = blockMap.get(blockKey);
  const parentId = block.getIn(['data', 'parentId']);
  return blockMap.filter(b => !!(b && b.getIn(['data', 'parentId']) === parentId)).reverse().find(b => !!(b && b.getIn(['data', 'pos']) < block.getIn(['data', 'pos'])));
}
/**
 * It returns block with all it's descendants, not just it's children
 * Everything inside tree with the block as the root node
 * @param blockMap
 * @param blockKey
 */

function getBlocksWithItsDescendants(blockMap, blockKey) {
  const block = blockMap.get(blockKey);
  return blockMap.toSeq().skipUntil((_, k) => k === blockKey).takeWhile((b, k) => !!(b && (k === blockKey || calculateDepth(blockMap, b.getKey()) > calculateDepth(blockMap, block.getKey()))));
}

function insertBlocksAtKey(blockMap, blocksToInsert, insertionBlockKey, insertBefore) {
  const insertionBlock = blockMap.get(insertionBlockKey);
  const blocksBeforeInsertionPoint = blockMap.toSeq().takeUntil((_, k) => k === insertionBlockKey);
  const blocksAfterInsertionPoint = blockMap.toSeq().skipUntil((_, k) => k === insertionBlockKey).rest();

  if (insertBefore) {
    return blocksBeforeInsertionPoint.concat(blocksToInsert).concat([[insertionBlockKey, insertionBlock]]).concat(blocksAfterInsertionPoint).toOrderedMap();
  } else {
    return blocksBeforeInsertionPoint.concat([[insertionBlockKey, insertionBlock]]).concat(blocksToInsert).concat(blocksAfterInsertionPoint).toOrderedMap();
  }
}

function insertBlocksAfter(blockMap, blocks, insertionBlockKey) {
  return insertBlocksAtKey(blockMap, blocks, insertionBlockKey, false);
}
/**
 * Will add a child to the given parentBlockKey after all of it's children.
 * If the parentBlockKey has no children, it will create a new child and add
 * that.
 */


function appendChild(blockMap, parentBlockKey, blockToAdd) {
  const blockWithItsChildren = getBlocksWithItsDescendants(blockMap, parentBlockKey);
  let blockToInsertAfterKey = parentBlockKey;
  const parentId = parentBlockKey;
  let pos = getPosNum(1); // if the block has some children

  if (blockWithItsChildren && blockWithItsChildren.count() > 1) {
    blockToInsertAfterKey = blockWithItsChildren.last().getKey();
    pos = getPosAfter(blockWithItsChildren.last().getIn(['data', 'pos']));
  }

  return insertBlocksAfter(blockMap, Immutable.OrderedMap({
    [blockToAdd.getKey()]: blockToAdd.setIn(['data', 'parentId'], parentId).setIn(['data', 'pos'], pos)
  }), blockToInsertAfterKey);
}
/**
 * Adds an empty block to the end of the list
 * If we are in a zoomed in state, we should add the block to the end of the
 * children list for the zoomedin item
 */


function addEmptyBlockToEnd(editorState, zoomedInItemId, depth) {
  const {
    contentState,
    blockMap
  } = pluckGoodies(editorState);
  const newBlock = getNewContentBlock({
    depth
  });
  let newBlockMap; // if we are at the root level, we can simply add the block to end of list

  if (!zoomedInItemId) {
    newBlockMap = blockMap.set(newBlock.getKey(), newBlock);
  } else {
    // otherwise we need to add the block to end of children list of the zoomed
    // in item. There can be 2 cases here
    // 1. The zoomed in item already has children
    // 2. The zoomed in item does not have any children
    // In this case, we can add the block after the zoomedin item and then call
    // onTab, which will make that block the zoomed in items child
    // OR - let's just write a appendChild method which takes care of both cases
    // internally
    newBlockMap = appendChild(blockMap, zoomedInItemId, newBlock);
  }

  const newSelection = draftJs.SelectionState.createEmpty(newBlock.getKey());
  const newContentState = contentState.merge({
    blockMap: newBlockMap,
    selectionBefore: newSelection,
    selectionAfter: newSelection.merge({
      anchorKey: newBlock.getKey(),
      anchorOffset: 0,
      focusKey: newBlock.getKey(),
      focusOffset: 0
    })
  }); // Always, always use this method to modify editorState when in doubt about
  // how to edit the editor state. It maintains the undo/redo stack for the
  // stack - https://draftjs.org/docs/api-reference-editor-state#push

  return draftJs.EditorState.forceSelection(draftJs.EditorState.push(editorState, newContentState, 'add-new-item'), newSelection);
}

/**
 * This is not a generic start and end keys function
 * It's very specific in that it finds the first item which is either a sibling
 * of the start item or higher than that. I.e. it finds all the children of the
 * first item
 * TODO: Can't we reuse getBlocksWithItsChildren here?
 */

function getStartAndEndKeys(contentState, selectionState) {
  const startBlockKey = selectionState.getAnchorKey();
  const blockWithItsChildren = getBlocksWithItsDescendants(contentState.getBlockMap(), startBlockKey);
  return [blockWithItsChildren.first().getKey(), blockWithItsChildren.last().getKey()];
}

function sortByPos(arr) {
  const newArr = [...arr];
  newArr.sort((item1, item2) => {
    // @ts-ignore
    return item1.getIn(['data', 'pos']) - item2.getIn(['data', 'pos']);
  });
  return newArr;
}
/**
 * Given a blockMap and a block id, this function traverses the tree from the given block id and returns all blocks under that tree
 * It makes some changes to the children as it traverses them
 *  1. It sorts the children by pos
 *  2. It updates the depth information
 */


function makeCorrectionsToNodeAndItsDescendants(blockMap, node) {
  const nodeDepth = node.getDepth();
  const nodeKey = node.getKey();
  const children = sortByPos(blockMap.filter(b => !!(b && b.getIn(['data', 'parentId']) === nodeKey)).map(b => {
    return b ? b.set('depth', nodeDepth + 1) : b;
  }).toArray()); // termination condition. The node is a leaf node.

  if (!children) {
    return [node];
  }

  return [node].concat(children.map(child => makeCorrectionsToNodeAndItsDescendants(blockMap, child)).flat());
}

/**
 * This function is super important for many edge cases of dedents
 * When an item in the middle of it's siblings is dedented, we can'j just
 * dedent that item and leave it there. It implies all it's siblings which
 * come after it will become it's children, which we don't want.
 * Just changing the parentId and pos of the dedented item means the data is
 * now correct, but the position of the block in our blockMap is not correct.
 * So we take the whole block of the dedented blocks new parent and regenrate
 * it based on the new parentId and pos data. That automatically puts the
 * dedented block in it's right place in the blockMap
 * TODO: This operation might be slow. Measure it's performance and tweak
 * it if required.
 * TODO: It does not work if the blocks are already not in correct position
 * E.g. I can't just set the parentId of some block to something new and
 * recreateParentBlockMap for that parentId and expect the block to be a child
 * of that new parent. Can we think of a way make sure that all items which
 * are supposed to be inside the given parentId are there?
 */

function recreateParentBlockMap(contentState, blockMap, parentId) {
  const selectionState = draftJs.SelectionState.createEmpty(parentId);
  const [startKey, endKey] = getStartAndEndKeys(contentState, selectionState);
  const startIndex = blockMap.keySeq().findIndex(k => k === startKey);
  const endIndex = blockMap.keySeq().findIndex(k => k === endKey); // the main thing nodeWithItsChildren does is sort the children inside a parent by it's pos. We rely on that to ensure that the sorting is correct after we set change the pos of some block

  const recreatedContentState = draftJs.ContentState.createFromBlockArray(makeCorrectionsToNodeAndItsDescendants(blockMap, blockMap.get(parentId)));
  const recreatedBlocks = recreatedContentState.getBlockMap();
  const recreatedBlockMap = blockMap.slice(0, startIndex).concat(recreatedBlocks, blockMap.slice(endIndex + 1));
  return recreatedBlockMap;
}

// TODO: add order to the newly created blocks
// TODO: Write unit tests for this function
// TODO: Adjust the hasChildren attribute of both the newly created block as well as their
// parent blocks, in case the newly created block becomes a child of some block

function splitBlock(editorState, zoomedInItemId) {
  const {
    contentState,
    selectionState,
    blockMap
  } = pluckGoodies(editorState); // only allow split block when nothing is selected

  if (!selectionState.isCollapsed()) {
    return editorState;
  }

  const key = selectionState.getAnchorKey();
  let blockToSplit = blockMap.get(key);
  const text = blockToSplit.getText();
  const isBlockCollapsed = blockToSplit.getIn(['data', 'collapsed']);
  const isBlockToSplitZoomedIn = zoomedInItemId === blockToSplit.getKey();
  let offset = selectionState.getAnchorOffset(); // if we calculate offset, pos and parentId, we are good to go.
  // we can set the new text on the split block and create a
  // new block with parentId and pos and recreateParentBlock

  let pos, parentId;
  const chars = blockToSplit.getCharacterList(); // if user presses enter when cursor is at the start of line of a zoomed in
  // item, we want to create a new empty child item instead of pushing the whole
  // line of zoomed in item to the child

  if (isBlockToSplitZoomedIn && offset === 0) {
    offset = blockToSplit.getText().length;
  } // if the block to split is the zoomed in item, we need to add the new item
  // as a child, i.e. depth greater than the block being split
  // We also want to do that for all kinds of parent items when they are not collapsed
  // Every zoomed in item is a parent and we might want to remove that condition altogether
  // but that will not work since a zoomed in item might be collapsed


  if (isBlockToSplitZoomedIn || !isBlockCollapsed && hasChildren(blockMap, blockToSplit.getKey()) && // we don't want to create a new child if the split is with cursor at the beginning
  // of the line. Then just create a new block above the current block
  selectionState.getStartOffset() !== 0) {
    // the child can either be the first child EVER of the item
    // or one of the chlidren. In the second case, we need to calculate the pos carefully
    const zoomedInBlockChildren = getChildren(blockMap, blockToSplit.getKey());

    if (zoomedInBlockChildren.count() > 0) {
      pos = getPosInBetween(0, zoomedInBlockChildren.first().getIn(['data', 'pos']));
    } else {
      pos = getPosNum(1);
    }

    parentId = blockToSplit.getKey();
  } else {
    const nextSibling = getNextSibling(blockMap, blockToSplit.getKey());

    if (nextSibling) {
      pos = getPosInBetween(blockToSplit.get('data').get('pos'), nextSibling.get('data').get('pos'));
    } else {
      pos = getPosAfter(blockToSplit.getIn(['data', 'pos']));
    }

    parentId = blockToSplit.getIn(['data', 'parentId']); // if we are inserting a block above current block by keeping cursor at beginning of line and pressing enter

    if (selectionState.getStartOffset() === 0) {
      const tempPos = blockToSplit.getIn(['data', 'pos']);
      blockToSplit = blockToSplit.setIn(['data', 'pos'], pos);
      pos = tempPos;
      offset = blockToSplit.getText().length;
    }
  }

  let newBlockMap = blockMap.set(blockToSplit.getKey(), blockToSplit.set('text', text.slice(0, offset)).set('characterList', chars.slice(0, offset)));
  const newBlock = getNewContentBlock({
    text: text.slice(offset)
  }).set('depth', blockMap.get(parentId).getDepth() + 1).setIn(['data', 'parentId'], parentId).setIn(['data', 'pos'], pos);
  newBlockMap = newBlockMap.set(newBlock.getKey(), newBlock);
  newBlockMap = recreateParentBlockMap(contentState.merge({
    blockMap: newBlockMap
  }), newBlockMap, parentId);
  const newContentState = contentState.merge({
    blockMap: newBlockMap,
    selectionBefore: selectionState,
    selectionAfter: selectionState.merge({
      anchorKey: newBlock.getKey(),
      anchorOffset: 0,
      focusKey: newBlock.getKey(),
      focusOffset: 0,
      isBackward: false
    })
  }); // Always, always use this method to modify editorState when in doubt about
  // how to edit the editor state. It maintains the undo/redo stack for the
  // stack - https://draftjs.org/docs/api-reference-editor-state#push

  return draftJs.EditorState.push(editorState, newContentState, 'split-block');
}

function findParent(editorState, blockKey) {
  const {
    blockMap
  } = pluckGoodies(editorState);
  const block = blockMap.get(blockKey);
  const parentBlock = blockMap.toSeq().takeUntil((_, k) => k === blockKey).reverse().skipWhile(b => !!(b && calculateDepth(blockMap, b.getKey()) >= calculateDepth(blockMap, block.getKey()))).first();
  return parentBlock;
}

function DownArrow(props) {
  return React.createElement("svg", Object.assign({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 24 24"
  }, props), React.createElement("path", {
    d: "M12 21l-12-18h24z"
  }));
}

var styles$2 = {"disc-container":"disc_styles-module_disc-container__3t72L","collapse-button":"disc_styles-module_collapse-button__116tC","down-arrow-icon":"disc_styles-module_down-arrow-icon__2wGmr","collapsed-down-arrow-icon":"disc_styles-module_collapsed-down-arrow-icon__2c6c9","disc":"disc_styles-module_disc__MiMX-","disc-collapsed":"disc_styles-module_disc-collapsed__2A4lQ","disc-icon":"disc_styles-module_disc-icon__1QagH"};

/*
 * 18. Tip - If i don't add `contentEditable={false}` in the Disc outer div,
 * clicking the mouse on the disc puts the cursor there, as if the whole disc
 * is content editable. I think draft-js, by default, makes all html elements
 * inside it as contenteditable. So if we don't want something as editable
 * entities, we have to specifiy it explicitly.
 *
 * 19. Question? - Is it better to use Entities for this? Define an entity which is
 * IMMUTABLE and then tell that Disc is that type of entity?
 */

function Disc({
  collapsed,
  itemId,
  isCollapsible
}) {
  const {
    onZoom,
    onExpandClick,
    onCollapseClick
  } = React.useContext(EditorContext);
  return React.createElement("div", {
    className: styles$2['disc-container'],
    style: {
      marginTop: 2
    }
  }, isCollapsible && React.createElement("button", {
    className: styles$2['collapse-button'],
    style: {
      marginTop: -2
    },
    onClick: () => {
      if (collapsed) {
        if (typeof onExpandClick === 'function') {
          onExpandClick(itemId);
        }
      } else {
        if (typeof onCollapseClick === 'function') {
          onCollapseClick(itemId);
        }
      }
    },
    "data-testid": "collapse-arrow"
  }, React.createElement(DownArrow, {
    className: classNames(styles$2['down-arrow-icon'], {
      [styles$2['collapsed-down-arrow-icon']]: collapsed
    }),
    width: 8,
    height: 8
  })), React.createElement("div", {
    contentEditable: false,
    className: classNames(styles$2['disc'], {
      [styles$2['disc-collapsed']]: collapsed
    }),
    onClick: () => {
      if (typeof onZoom === 'function') {
        onZoom(itemId);
      }
    },
    "data-testid": "outer-disc"
  }, React.createElement("svg", {
    width: "6",
    height: "6",
    className: styles$2['disc-icon'],
    viewBox: "0 0 6 6"
  }, React.createElement("circle", {
    cx: "3",
    cy: "3",
    r: "3"
  }))));
}

function PlusSign(props) {
  return React.createElement("svg", Object.assign({
    version: "1.1",
    id: "Capa_1",
    xmlns: "http://www.w3.org/2000/svg",
    xmlnsXlink: "http://www.w3.org/1999/xlink",
    x: "0px",
    y: "0px",
    viewBox: "0 0 512 512",
    enableBackground: "new 0 0 512 512",
    xmlSpace: "preserve"
  }, props), React.createElement("g", null, React.createElement("g", null, React.createElement("path", {
    d: "M492,236H276V20c0-11.046-8.954-20-20-20c-11.046,0-20,8.954-20,20v216H20c-11.046,0-20,8.954-20,20s8.954,20,20,20h216\n\t\t\tv216c0,11.046,8.954,20,20,20s20-8.954,20-20V276h216c11.046,0,20-8.954,20-20C512,244.954,503.046,236,492,236z"
  }))));
}

function MinusSign(props) {
  return React.createElement("svg", Object.assign({
    version: "1.1",
    id: "Capa_1",
    xmlns: "http://www.w3.org/2000/svg",
    xmlnsXlink: "http://www.w3.org/1999/xlink",
    x: "0px",
    y: "0px",
    viewBox: "0 0 512 512",
    enableBackground: "new 0 0 512 512",
    xmlSpace: "preserve"
  }, props), React.createElement("g", null, React.createElement("rect", {
    y: 236,
    width: 512,
    height: 40
  })));
}

var styles$3 = {"item-base":"item_styles-module_item-base__3sOp0","completed":"item_styles-module_completed___ObuM","zoomed-in-item":"item_styles-module_zoomed-in-item__18pC6","regular-item":"item_styles-module_regular-item__23xsf","small-text":"item_styles-module_small-text__u0K1d","item-container":"item_styles-module_item-container__3B3Jx","mobile-collapse-button":"item_styles-module_mobile-collapse-button__3cd1_","depth-manager":"item_styles-module_depth-manager__1pfhr"};

/**
 * Hacky but works
 * We wrap the item in nested divs each with class depth-manager mainly to get
 * the vertical line which connects the various item bullet dot together.
 * If we simply adding a margin-left of (depth * someMargin) on the item div
 * itself, we would not be able to show that vertical line by simply adding
 * a left-border and. The left border trick works only by creating the left
 * space in each depth-manager using a padding. It won't work with a margin-left
 */

function wrapInNestedDivs(el, props, depth) {
  if (depth <= 0) {
    return el;
  }

  return React.createElement('div', props, wrapInNestedDivs(el, props, depth - 1));
}

function areEqual(prevProps, newProps) {
  const {
    block: prevBlock,
    blockProps: {
      hidden: prevHidden,
      baseDepth: prevBaseDepth,
      searchText: prevSearchText
    }
  } = prevProps;
  const {
    block: nextBlock,
    blockProps: {
      hidden: nextHidden,
      baseDepth: nextBaseDepth,
      searchText: nextSearchText
    }
  } = newProps;
  return prevBlock === nextBlock && prevHidden === nextHidden && prevBaseDepth === nextBaseDepth && prevSearchText === nextSearchText;
}

const Item = /*#__PURE__*/React.memo(props => {
  const {
    block,
    blockProps
  } = props;
  const {
    onExpandClick,
    onCollapseClick,
    hidden,
    baseDepth,
    zoomedInItemId
  } = blockProps;
  const collapsed = block.getIn(['data', 'collapsed']);
  const completed = block.getIn(['data', 'completed']);
  const collapsible = block.getIn(['data', 'hasChildren']);
  /*
   * 7. When i try rendering the block on my own by wrapping the list item
   * EditorBlock inside my own html, it puts the whole div inside the rendered
   * li! So i 1. wrote css to hide the bullet for the li(s). 2. Render a small
   * circle like bullet of my own before the EditorBlock renders the text.
   *
   * Now i can control the various looks of the bullet based on
   * 1. Whether they are collapsed or not
   * 2. Whether user has marked it complete or not
   * 3. And i can add the arrow before the bullet to allow users to collapse or
   * expand a list item
   */

  if (hidden) {
    return null;
  }

  const depth = block.getDepth(); // most of the conditional classes are for the zoomed in item. It's special.

  const itemClasses = classNames(styles$3['item-base'], {
    [styles$3.completed]: completed,
    [styles$3['regular-item']]: zoomedInItemId !== block.getKey(),
    [styles$3['zoomed-in-item']]: zoomedInItemId === block.getKey(),
    [styles$3['small-text']]: zoomedInItemId !== block.getKey() && depth > baseDepth + 1
  });
  return wrapInNestedDivs(React.createElement("div", {
    className: itemClasses,
    style: {
      marginLeft: -13
    },
    "data-testid": "list-item"
  }, block.getDepth() > baseDepth && React.createElement(Disc, {
    itemId: block.getKey(),
    collapsed: !!collapsed,
    isCollapsible: collapsible
  }), React.createElement("div", {
    className: styles$3['item-container']
  }, React.createElement(draftJs.EditorBlock, Object.assign({}, props)), collapsible ? !collapsed ? React.createElement("button", {
    contentEditable: false,
    className: styles$3['mobile-collapse-button'],
    onMouseDown: e => {
      e.stopPropagation();
      e.nativeEvent.stopImmediatePropagation();
      onCollapseClick(block.getKey());
    },
    "data-testid": "collapse-button"
  }, React.createElement(MinusSign, {
    width: 16,
    height: 16
  })) : React.createElement("button", {
    contentEditable: false,
    className: styles$3['mobile-collapse-button'],
    onMouseDown: e => {
      e.stopPropagation();
      e.nativeEvent.stopImmediatePropagation();
      onExpandClick(block.getKey());
    },
    "data-testid": "expand-button"
  }, React.createElement(PlusSign, {
    width: 16,
    height: 16
  })) : null)), {
    className: classNames('depth-manager', styles$3['depth-manager'])
  }, depth - baseDepth - 1);
}, areEqual);
Item.displayName = 'Item';

function pasteText(editorState, pastedText) {
  const {
    contentState,
    selectionState
  } = pluckGoodies(editorState);
  return draftJs.EditorState.push(editorState, draftJs.Modifier.replaceText(contentState, selectionState, pastedText), 'paste-text');
}

function moveBlock(contentState, blockToSwapWith, blockToMoveKey, newParentId, newPos) {
  const blockMap = contentState.getBlockMap();
  let anchorBlock = blockMap.get(blockToMoveKey);
  const parentId = anchorBlock.getIn(['data', 'parentId']);
  anchorBlock = anchorBlock.setIn(['data', 'parentId'], newParentId).setIn(['data', 'pos'], newPos);
  let newBlockMap = blockMap.set(blockToMoveKey, anchorBlock).set(blockToSwapWith.getKey(), blockToSwapWith); // the order of operation for redoing the recreateParentBlockMap for
  // parentId and newParentId is very important.
  // because OrderedMap is also a map at the end of the day,
  // so .concat works weirdly if we try to concatenate something which is
  // already present in the map
  // If we are moving something to new parent, wouldn't a single call to
  // recreateParentBlockMap solve all our problems? i.e. wouldn't it
  // automatically remove the block from it's previous position? No. Because the
  // block will be with it's old parent in the map and when trying to
  // concatenate a small part of the tree in a different node, the OrderedMap
  // would probably keep only one version of the altered block. Probably the
  // one which comes earlier. I don't know.
  // If we are doing a move, updating the current parent tree should essentially
  // delete the block from the whole blockMap

  newBlockMap = recreateParentBlockMap(contentState.set('blockMap', newBlockMap), newBlockMap, parentId); // all we have to do is again reattach the anchorBlock to newBlockMap before
  // recreating the newParentId tree

  if (newParentId !== parentId) {
    newBlockMap = newBlockMap.merge(getBlocksWithItsDescendants(blockMap, blockToMoveKey));
    newBlockMap = newBlockMap.set(blockToMoveKey, anchorBlock);
    newBlockMap = recreateParentBlockMap(contentState.set('blockMap', newBlockMap), newBlockMap, newParentId);
  }

  return newBlockMap;
}

function getBlockToInsertBefore(editorState) {
  const {
    blockMap,
    anchorKey
  } = pluckGoodies(editorState);
  const block = blockMap.get(anchorKey);
  const previousSibling = getPreviousSibling(blockMap, anchorKey); // two cases
  // 1. Either move the item before it's previous sibling
  // 2. If there is no previous sibling, move it as the last child of the previous sibling of it's parent

  if (previousSibling) {
    return previousSibling;
  }

  const parent = blockMap.get(block.getIn(['data', 'parentId']));
  const parentsPreviousSibling = getPreviousSibling(blockMap, parent.getKey());

  if (!parentsPreviousSibling) {
    return null;
  }

  const children = getChildren(blockMap, parentsPreviousSibling.getKey());

  if (children.count() > 0) {
    return children.last();
  } else {
    return parentsPreviousSibling;
  }
} // which block should we insert the current block after when moving down?
// Can't just take the next one and say insert after that. Don't want to do
// that if it's the child of the block to be moved


function getBlockToInsertAfter(editorState) {
  const {
    blockMap,
    anchorKey
  } = pluckGoodies(editorState);
  const block = blockMap.get(anchorKey);
  const nextSibling = getNextSibling(blockMap, anchorKey); // two cases
  // 1. Either move the item after it's next sibling
  // 2. If there is no next sibling, it's the last child. Move it as the first child of the next sibling of the parent

  if (nextSibling) {
    return nextSibling;
  }

  const parent = blockMap.get(block.getIn(['data', 'parentId']));
  const parentNextSibling = getNextSibling(blockMap, parent.getKey());

  if (!parentNextSibling) {
    return null;
  }

  return parentNextSibling;
}

function moveCurrentBlockUp(editorState, zoomedInItemId) {
  const {
    contentState,
    blockMap,
    selectionState,
    anchorKey
  } = pluckGoodies(editorState);
  let blockToSwapWith = getBlockToInsertBefore(editorState);

  if (!blockToSwapWith) {
    console.log('moveCurrentBlockUp', 'nothing to swap with');
    return editorState;
  } // we are trying to move a block above the currently zoomed in item, do
  // nothing


  if (zoomedInItemId && (blockToSwapWith.getKey() === zoomedInItemId || contentState.getBlockAfter(blockToSwapWith.getKey()) && contentState.getBlockAfter(blockToSwapWith.getKey()).getKey() === zoomedInItemId)) {
    return editorState;
  }
  /*
   * This will not work when we move multiple blocks or move blocks across
   * depths. E.g. if i move a child item in depth 1 up, it should not replace
   * it's parent but move beyond that and as a child of the earlier higher level
   * item. Such things are much better done with a 'delete and insert' operation
   *
   * 1. Determine the key of block to be remove - anchorKey
   * 2. Determine the index where it needs to be inserted
   * 3. Delete the block from map using key
   * 4. Convert blockMap to seq and insert the deleted block at (index - 1).
   * Maybe using concat like we are doing below or some better way.
   * If nothing else, let's fallback to our trusted `reduce` :)
   *
   * Will need a separate algorithm when we need to move multiple blocks
   * because the block to be moved is collapsed.
   *
   */


  const anchorBlock = blockMap.get(anchorKey); // Instead of doing so many shenanigans, all we need to determine
  // is the blocks new parentId and pos. There might be 2 cases with parentId
  // 1. It remains the same
  // 2. It changes
  // In case 1. we call recreateParentBlockMap after changing the pos for
  // affected blocks (swapped ones)
  // In case 2. we change parentId of moved block and it's pos and then
  // call recreateParentBlockMap for both the new and the old parentIds

  const parentId = anchorBlock.getIn(['data', 'parentId']);
  let newParentId;
  let newPos;

  if (blockToSwapWith.getIn(['data', 'parentId']) === parentId) {
    newParentId = parentId;
    newPos = blockToSwapWith.getIn(['data', 'pos']);
    blockToSwapWith = blockToSwapWith.setIn(['data', 'pos'], anchorBlock.getIn(['data', 'pos']));
  } else {
    // we are moving below the child the preceding parent block
    if (calculateDepth(blockMap, blockToSwapWith.getKey()) === calculateDepth(blockMap, anchorBlock.getKey())) {
      newParentId = blockToSwapWith.getIn(['data', 'parentId']);
      newPos = getPosAfter(blockToSwapWith.getIn(['data', 'pos']));
    } else {
      // we are probably moving inside an item without any children
      newParentId = blockToSwapWith.getKey();
      newPos = getPosNum(1);
    }
  }

  const newBlockMap = moveBlock(contentState, blockToSwapWith, anchorKey, newParentId, newPos);
  const newContentState = contentState.merge({
    blockMap: newBlockMap
  });
  const newSelection = new draftJs.SelectionState({
    anchorKey: anchorKey,
    anchorOffset: selectionState.getAnchorOffset(),
    focusKey: anchorKey,
    focusOffset: selectionState.getFocusOffset()
  }); // Always, always use this method to modify editorState when in doubt about
  // how to edit the editor state. It maintains the undo/redo stack for the
  // stack - https://draftjs.org/docs/api-reference-editor-state#push

  const newState = draftJs.EditorState.push(editorState, newContentState, 'move-block');
  return draftJs.EditorState.forceSelection(newState, newSelection);
}
function moveCurrentBlockDown(editorState, zoomedInItemId) {
  const {
    contentState,
    selectionState,
    blockMap,
    anchorKey
  } = pluckGoodies(editorState); // TODO: write function to find the block to swap with when dealing with
  // nested items

  let blockToSwapWith = getBlockToInsertAfter(editorState);

  if (!blockToSwapWith || blockToSwapWith.getKey() === anchorKey) {
    console.log('moveCurrentBlockDown', 'nothing to swap with');
    return editorState;
  }

  const anchorBlock = blockMap.get(anchorKey); // Instead of doing so many shenanigans, all we need to determine
  // is the blocks new parentId and pos. There might be 2 cases with parentId
  // 1. It remains the same
  // 2. It changes
  // In case 1. we call recreateParentBlockMap after changing the pos for
  // affected blocks (swapped ones)
  // In case 2. we change parentId of moved block and it's pos and then
  // call recreateParentBlockMap for both the new and the old parentIds

  const parentId = anchorBlock.getIn(['data', 'parentId']);
  let newParentId;
  let newPos; // We found a sibling to swap positions with

  if (blockToSwapWith.getIn(['data', 'parentId']) === parentId) {
    newParentId = parentId;
    newPos = blockToSwapWith.getIn(['data', 'pos']);
    blockToSwapWith = blockToSwapWith.setIn(['data', 'pos'], anchorBlock.getIn(['data', 'pos']));
  } else {
    // we might be trying to push the item to the zoomed in items next sibling
    // which will make the block disappear from the zoomed in editor state
    // let's not allow that
    if (zoomedInItemId === anchorBlock.getIn(['data', 'parentId'])) {
      return editorState;
    } // the blockToSwapWith has to be it's parent, if eligible


    newParentId = blockToSwapWith.getKey();
    const firstChild = getFirstChild(blockMap, blockToSwapWith.getKey()); // const newParentsChildren = getChildren(blockMap, blockToSwapWith.getKey());
    // we are moving above the first child of the next parent block
    // case 1 - If there are already some parents present

    if (firstChild) {
      newPos = getPosInBetween(0, firstChild.getIn(['data', 'pos']));
    } else {
      // case 2 - There are not existing children. This item will be the first child.
      newPos = getPosNum(1);
    }
  }

  const newBlockMap = moveBlock(contentState, blockToSwapWith, anchorKey, newParentId, newPos);
  const newContentState = contentState.merge({
    blockMap: newBlockMap
  });
  const newSelection = new draftJs.SelectionState({
    anchorKey: anchorKey,
    anchorOffset: selectionState.getAnchorOffset(),
    focusKey: anchorKey,
    focusOffset: selectionState.getFocusOffset()
  }); // Always, always use this method to modify editorState when in doubt about
  // how to edit the editor state. It maintains the undo/redo stack for the
  // stack - https://draftjs.org/docs/api-reference-editor-state#push

  const newState = draftJs.EditorState.push(editorState, newContentState, 'move-block');
  return draftJs.EditorState.forceSelection(newState, newSelection);
}

function toggleCollapseState(editorState, collapseState, blockKey) {
  const {
    contentState,
    selectionState,
    blockMap
  } = pluckGoodies(editorState);
  const block = blockMap.get(blockKey); // if the block does not exists
  // or if the collapsed state is already in the desired state, let it be

  if (!block || block.getIn(['data', 'collapsed']) === collapseState) {
    return editorState;
  }

  const blockWithItsChildren = getBlocksWithItsDescendants(blockMap, blockKey); // if this list contains just one item, it's that block itself. There are
  // no children to collapse

  if (!blockWithItsChildren || blockWithItsChildren.count() === 1) {
    return editorState;
  }

  const newContentState = contentState.merge({
    blockMap: blockMap.set(blockKey, block.setIn(['data', 'collapsed'], collapseState))
  });
  const newSelection = new draftJs.SelectionState({
    anchorKey: blockKey,
    anchorOffset: selectionState.getAnchorOffset(),
    // There is a bug where when i click expand/collapse arrow of any item, the
    // draft-js code throws an exception. It seems to happen consistently when
    // i click the first item arrow with mouse. Happens randomly for other
    // items on and off.
    // And looks like it doesn't happen again if i set the focusKey to
    // undefined. Definitely not an ideal bug fix.
    // TODO: figure out why this might happen. What is the focusKey exactly
    // doing?
    focusKey: undefined,
    focusOffset: selectionState.getFocusOffset()
  });
  const newState = draftJs.EditorState.push(editorState, newContentState, collapseState ? 'collapse-list' : 'expand-list');
  return draftJs.EditorState.forceSelection(newState, newSelection);
}

function collapseBlock(editorState, blockKey) {
  const {
    anchorKey
  } = pluckGoodies(editorState);
  return toggleCollapseState(editorState, true, blockKey || anchorKey);
}
function expandBlock(editorState, blockKey) {
  const {
    anchorKey
  } = pluckGoodies(editorState);
  return toggleCollapseState(editorState, false, blockKey || anchorKey);
}
/*
 * bug - if the cursor is at end of line of the list item, expand does
 * not work. If the cursor is anywhere else on the line, it works
 * Root cause - selectionState.getAnchorKey, getStartKey, getFocusKey - all
 * return the wrong information when the cursor is at the end of line. They
 * return the last child of the collapsed item as the anchor block
 * Once we collapse the item, the selection state goes wrong. It sets itself
 * to the last child of the collapsed item. Probably because draftjs also
 * handles command+up or command+down? don't know.
 *
 * bug - Once expanded, creating new item with 'Enter' key creates the
 * new item as a child of the current item. Because the selectionState is
 * pointing to the last child of this item. Just hiding the block with
 * display: none is not a viable solution. Also because we are not controlling
 * the wrapper li for each list item. That's controlled by draft-js. We
 * are just hiding the content inside that li. We might need to completely
 * remove those blocks from contentState when collapsing items. And maintain
 * a master contentState somewhere. But that would create problems of
 * syncing that master contentState with changed contentState while editing
 * a current one which has one or more collapsed items. Hmm...
 */

function getParentIdAfterAdjustment(contentState, indentBlockKey, newDepth) {
  let previousBlock = contentState.getBlockBefore(indentBlockKey);
  const blockMap = contentState.getBlockMap(); // TODO: Add description about what we are doing in this while loop

  while (previousBlock) {
    if (calculateDepth(blockMap, previousBlock.getKey()) < newDepth) {
      return previousBlock.getKey();
    }

    previousBlock = contentState.getBlockBefore(previousBlock.getKey());
  }

  return ROOT_KEY;
}
/**
 * Once we find the parentId after indent or dedent, we don't need the exact
 * operation which was performed. We can use the parentId to get all the current
 * nodes with same parentId, the adjusted blocks position in those children
 * and hence the adjusted blocks new postion
 */


function getPosAfterAdjustment(blockMap, adjustedBlockKey, newParentId) {
  // we get the blockMap with adjusted parentId. This will help us get the
  // position of the adjusted block in the children list
  const blocksWithSameParent = blockMap.filter(b => !!(b && b.get('data').get('parentId') === newParentId)).toArray();
  let i = 0;
  let blockBefore;
  let blockAfter;

  while (i < blocksWithSameParent.length) {
    // once we find the adjustment block, we know the surrounding 2 are
    // actually it's blockBefore and blockAfter at the same depth
    if (blocksWithSameParent[i].getKey() === adjustedBlockKey) {
      blockBefore = blocksWithSameParent[i - 1];
      blockAfter = blocksWithSameParent[i + 1];
      break;
    }

    i += 1;
  }

  if (blockBefore && blockAfter) {
    return getPosInBetween(blockBefore.get('data').get('pos'), blockAfter.get('data').get('pos'));
  } else if (blockBefore) {
    return getPosAfter(blockBefore.get('data').get('pos'));
  } else if (blockAfter) {
    return getPosNum(1);
  } else {
    return getPosNum(1);
  }
} // adjust block depth by +1 or -1 for the current item as well as all it's
// children and the children of children recursively. We don't need to do it
// recursively in this case because draftjs blockMap is ordered and we know
// that we have handled all the descendents of the current item when we reach
// another item which is at same depth as current item


function adjustBlockDepthForContentState(contentState, selectionState, adjustment) {
  // TODO: can we not use getBlocksWithItsChildren here? Probably not since we
  // need any grandchildren and their children and theirs
  const indentBlockKey = selectionState.getAnchorKey();
  let blockMap = contentState.getBlockMap();
  let indentBlock = blockMap.get(indentBlockKey);
  const newDepth = calculateDepth(blockMap, indentBlockKey) + adjustment;
  const oldParentId = indentBlock.getIn(['data', 'parentId']); // TODO: When we dedent an item which is in between it's other siblings,
  // we need to create the list of items from this dedented item's parent and
  // downwards again and completely replace that list in the current blockMap.
  // It will lead to things like an a middle sibling being dedented changing it's
  // position in the list after the end of it's siblings but one level up.
  // Check workflowy behavior.
  // The only way to do it seems to be rearranging everything inside the parent
  // of this dedented item.
  // we can use arrToObj and loadFromDb functions to rearrange the affected
  // blocks. Using getStartAndEndKeys we can get the blocks array from our
  // blockMap and then use arrToObj to create an object map of the blocks and
  // pass it to loadFromDb to get a block array again.
  // To update the blocks inside BlockMap, which is an OrderedMap, we have to
  // use the same trick that we use in splitBlock. Create a aboveBlocks,
  // betweenBlocks and afterBlocks arrays and merge them to make the final
  // blockMap again.
  // something like
  // blockMap.slice(0, indentBlockKey)
  //    .concat(Immutable.OrderedMap(
  //       // from [{ key: 'a' }, { key: 'b' } ] to
  //       // [ ['a', { key: 'a' }], ['b', { key: 'b' }]]
  //       // so that Immutable.OrderedMap can consume it correctly
  //       convertToKeyValuePairs(
  //         loadFromDb(new DB(blockMap.slice(indentBlockKey, endKey).toJS()))
  //       )
  //     )
  //    .concat(blockMap.slice(endKey))
  // Let's call that function recreateParentBlockMap()

  const parentId = getParentIdAfterAdjustment(contentState, indentBlockKey, newDepth);
  indentBlock = indentBlock.setIn(['data', 'parentId'], parentId); // we need to update blockMap before we send it to getPosAfterAdjustment

  blockMap = blockMap.set(indentBlock.getKey(), indentBlock);
  indentBlock = indentBlock.setIn(['data', 'pos'], getPosAfterAdjustment(blockMap, indentBlock.getKey(), parentId)); // set new parent id

  blockMap = blockMap.set(indentBlockKey, indentBlock);
  blockMap = recreateParentBlockMap(contentState.set('blockMap', blockMap), blockMap, parentId); // if the parent block is collapsed, expand it
  // otherwise we won't be able to see where the indented block went

  if (adjustment === 1) {
    const parentBlock = blockMap.get(parentId);

    if (parentBlock.getIn(['data', 'collapsed'])) {
      blockMap = blockMap.set(parentId, parentBlock.setIn(['data', 'collapsed'], false));
    }
  } // We want to adjust the hasChildren property of both the old parent block as well
  // as the new parent block for the indented/dedented block


  blockMap = adjustHasChildren(adjustHasChildren(blockMap, oldParentId), parentId);
  return contentState.merge({
    blockMap,
    selectionBefore: selectionState,
    selectionAfter: selectionState
  });
}
/*
 * Overriding the draft-js provided onTab function since it doesn't work on
 * multiple list items, i.e. an hierarchy of items. If i press tab on an item
 * which has children, it should move into the previous sibling along with all
 * it's children.
 * TODO: update parentKeys as appropriate
 */


function onTab(editorState, maxDepth, zoomedInItemId, shiftKey = false) {
  const selection = editorState.getSelection(); // TODO: Why are we using startBlockKey here? Why not anchorKey

  const startBlockKey = selection.getStartKey();
  const content = editorState.getCurrentContent();
  const blockMap = content.getBlockMap();
  const startBlock = content.getBlockForKey(startBlockKey);
  const previousBlock = content.getBlockBefore(startBlockKey);
  const baseDepth = zoomedInItemId ? calculateDepth(blockMap, zoomedInItemId) + 1 : 0;

  if ( // if the first block in selection is the first block overall, don't do
  // anything. Either for tab or for shift-tab
  !previousBlock || // if we are trying to change depth of the zoomed in item itself
  calculateDepth(blockMap, startBlock.getKey()) < baseDepth || // if we are trying to dedent the direct children of the zoomed in item
  shiftKey && calculateDepth(blockMap, startBlock.getKey()) === baseDepth) {
    console.log('This seems like the first list item. Nothing to do.');
    return editorState;
  }

  const depth = calculateDepth(blockMap, startBlock.getKey());

  if (depth >= maxDepth) {
    return editorState;
  } // we don't want a difference of more than one level between an item and
  // it's previous block


  if (!shiftKey && calculateDepth(blockMap, startBlock.getKey()) - calculateDepth(blockMap, previousBlock.getKey()) >= 1) {
    return editorState;
  }

  const withAdjustment = adjustBlockDepthForContentState(content, selection, shiftKey ? -1 : 1); // Always, always use this method to modify editorState when in doubt about
  // how to edit the editor state. It maintains the undo/redo stack for the
  // stack - https://draftjs.org/docs/api-reference-editor-state#push

  return draftJs.EditorState.push(editorState, withAdjustment, 'adjust-depth');
}

const CHANGE = 'CHANGE';
const SET_ROOT_EDITOR_STATE = 'SET_ROOT_EDITOR_STATE';
const SET_EDITOR_STATE = 'SET_EDITOR_STATE';
const SET_STATE = 'SET_STATE';
const INSERT_SOFT_NEWLINE = 'INSERT_SOFT_NEWLINE';
const ZOOM = 'ZOOM';
const COLLAPSE_ITEM = 'COLLAPSE_ITEM';
const EXPAND_ITEM = 'EXPAND_ITEM';
const EXPAND_ALL = 'EXPAND_ALL';
const COLLAPSE_ALL = 'COLLAPSE_ALL';
const MOVE_UP = 'MOVE_UP';
const MOVE_DOWN = 'MOVE_DOWN';
const TOGGLE_COMPLETION = 'TOGGLE_COMPLETION';
const DELETE_CURRENT_ITEM = 'DELETE_CURRENT_ITEM ';
const INDENT = 'INDENT';
const DEDENT = 'DEDENT';
const BOOKMARK = 'BOOKMARK';

function updateSelectionForZoom(editorState, zoomedInItemId) {
  const {
    selectionState,
    blockMap
  } = pluckGoodies(editorState);
  let newSelectionState = selectionState;
  const blockWithItsChildren = getBlocksWithItsDescendants(blockMap, zoomedInItemId); // if the zoomed in item has children, let's focus the first child

  if (blockWithItsChildren.count() > 1) {
    // check if one of the children has focus
    const childWithFocus = blockWithItsChildren.find(block => !!(block && block.getKey() === selectionState.getAnchorKey())); // if one of the children has focus, just maintain that focus
    // else, focus the first child

    if (!childWithFocus) {
      const firstChild = blockWithItsChildren.rest().first();
      newSelectionState = draftJs.SelectionState.createEmpty(firstChild.getKey());
    }
  } else {
    // if the zoomed in item also has the focus, we should retain it's cursor
    // position. Else create new focus on the zoomedin item with cursor at
    // start of line.
    if (selectionState.getAnchorKey() !== zoomedInItemId) {
      newSelectionState = draftJs.SelectionState.createEmpty(zoomedInItemId);
    }
  }

  return draftJs.EditorState.forceSelection(editorState, newSelectionState);
} // This function create a new editorState with blocks only in the sub tree rooted at the zoomedInItemId
// function withBlocksForZoomedInItem(
// editorState: EditorState,
// zoomedInItemId: string,
// ) {
// const { blockMap } = pluckGoodies(editorState);
// const blocks = makeCorrectionsToNodeAndItsDescendants(
// blockMap,
// blockMap.get(zoomedInItemId),
// );
// return EditorState.createWithContent(
// ContentState.createFromBlockArray(blocks),
// );
// }


function zoomReducer(state, itemId) {
  const {
    editorState,
    zoomedInItemId
  } = state;
  const {
    blockMap
  } = pluckGoodies(editorState); // if there no zoomed in item, that means there's nothing to zoom out into
  // If the zoomed in fellow is same is item to zoom into, the zoom reducer
  // is probably called because the search text changed
  // can't be because now we removed searchText from query string

  if (zoomedInItemId === itemId) {
    console.log('We are at the root. Nothing to zoom out into.');
    return state;
  }

  let zoomedBlock; // if we are provided itemId to zoom out to

  if (itemId) {
    zoomedBlock = blockMap.get(itemId);
  }

  const newZoomedInItemId = zoomedBlock ? zoomedBlock.getKey() : ROOT_KEY; // if the zoom is done to the root level, there will be no particular block
  // to zoom into. And zoomedBlock would be empty in that case. And we
  // don't need to maintain a separate wholeEditorState

  return { ...state,
    // we forceupdate the editor state to itself so that the editor refreshes
    // If we don't do that, we set the new zoomedInItemId but the editor does
    // not render again with that information
    // TODO: Instead of forceupdate, we can update the selection on editorState
    // We anyways should do it on zoomins. Updating selection, even if it leads
    // to same selection state, would automatically get draftjs to rerender.
    editorState: updateSelectionForZoom(state.editorState, newZoomedInItemId),
    zoomedInItemId: newZoomedInItemId
  };
}

function toggleCompleteReducer(state) {
  const {
    blockMap,
    anchorBlock,
    contentState,
    selectionState
  } = pluckGoodies(state.editorState); // Don't do anything if the item is empty

  if (anchorBlock.getText().trim() === '') {
    return state;
  }

  const blocksWithItsDescendants = getBlocksWithItsDescendants(blockMap, anchorBlock.getKey());
  const newBlockMap = blockMap.merge(blocksWithItsDescendants.map(b => b ? b.setIn(['data', 'completed'], !anchorBlock.getIn(['data', 'completed'])) : b));
  const newContentState = contentState.merge({
    blockMap: newBlockMap,
    selectionBefore: selectionState,
    selectionAfter: selectionState
  });
  return { ...state,
    editorState: draftJs.EditorState.push(state.editorState, newContentState, 'toggle-completion')
  };
}

function deleteItemWithChildren(state) {
  const {
    editorState
  } = state;
  const {
    contentState,
    blockMap,
    focusKey,
    focusBlock
  } = pluckGoodies(editorState);

  if (!focusKey) {
    return state;
  }

  const blocksToDelete = getBlocksWithItsDescendants(blockMap, focusKey);
  const parentId = blockMap.get(focusKey).getIn(['data', 'parentId']);
  let newBlockMap = blockMap.toSeq().filter((_, k) => !!(k && !blocksToDelete.has(k))).toOrderedMap(); // don't allow deleting if there is only one item in the list

  if (!newBlockMap || newBlockMap.count() === 0 || // at root level, the block map will still have one item, the root item
  newBlockMap.count() === 1 && newBlockMap.has(ROOT_KEY)) {
    return state;
  }

  const pSibling = contentState.getBlockBefore(focusBlock.getKey());
  let newSelection;

  if (pSibling) {
    newSelection = new draftJs.SelectionState({
      anchorKey: pSibling.getKey(),
      anchorOffset: pSibling.getText().length - 1,
      focusKey: pSibling.getKey(),
      focusOffset: pSibling.getText().length - 1
    });
  } else {
    // what if it's the only item in the list?
    newSelection = draftJs.SelectionState.createEmpty(newBlockMap.toSeq().first().getKey());
  } // reset the hasChildren state of the parent block


  newBlockMap = adjustHasChildren(newBlockMap, parentId);
  return { ...state,
    editorState: draftJs.EditorState.push(editorState, contentState.merge({
      blockMap: newBlockMap,
      selectionBefore: newSelection,
      selectionAfter: newSelection
    }), 'delete-item')
  };
}

function expandCollapseAll(state, collapse) {
  const {
    editorState,
    zoomedInItemId
  } = state;
  const {
    blockMap,
    contentState
  } = pluckGoodies(editorState);
  let blocksWithItsDescendants = getBlocksWithItsDescendants(blockMap, zoomedInItemId);
  blocksWithItsDescendants = blocksWithItsDescendants.rest().map(b => {
    if (!b) {
      return b;
    } else {
      if (hasChildren(blockMap, b.getKey())) {
        return b.setIn(['data', 'collapsed'], collapse);
      } else {
        return b;
      }
    }
  });
  const newBlockMap = blockMap.merge(blocksWithItsDescendants);
  const newEditorState = draftJs.EditorState.push(editorState, contentState.set('blockMap', newBlockMap), 'collapse-all');
  return { ...state,
    editorState: newEditorState
  };
}

function toggleBookmark(editorState, zoomedInItemId) {
  const {
    blockMap,
    contentState
  } = pluckGoodies(editorState);
  const zoomedInBlock = blockMap.get(zoomedInItemId);
  const newBlockMap = blockMap.set(zoomedInItemId, zoomedInBlock.setIn(['data', 'bookmarked'], !zoomedInBlock.getIn(['data', 'bookmarked'])));
  return draftJs.EditorState.push(editorState, contentState.set('blockMap', newBlockMap), 'bookmark');
}

function rootReducer(state, action) {
  switch (action.type) {
    case CHANGE:
      return { ...state,
        editorState: action.editorState
      };

    case INSERT_SOFT_NEWLINE:
      return { ...state,
        editorState: draftJs.RichUtils.insertSoftNewline(state.editorState)
      };

    case SET_ROOT_EDITOR_STATE:
      return { ...state,
        rootEditorState: action.editorState
      };

    case SET_EDITOR_STATE:
      return { ...state,
        editorState: action.editorState
      };

    case SET_STATE:
      return { ...state,
        [action.prop]: action.val
      };

    case MOVE_UP:
      return { ...state,
        editorState: moveCurrentBlockUp(state.editorState, state.zoomedInItemId)
      };

    case MOVE_DOWN:
      return { ...state,
        editorState: moveCurrentBlockDown(state.editorState, state.zoomedInItemId)
      };

    case COLLAPSE_ITEM:
      return { ...state,
        editorState: collapseBlock(state.editorState, action.blockKey)
      };

    case EXPAND_ITEM:
      return { ...state,
        editorState: expandBlock(state.editorState, action.blockKey)
      };

    case EXPAND_ALL:
      return expandCollapseAll(state, false);

    case COLLAPSE_ALL:
      return expandCollapseAll(state, true);

    case TOGGLE_COMPLETION:
      return toggleCompleteReducer(state);

    case DELETE_CURRENT_ITEM:
      return deleteItemWithChildren(state);

    case ZOOM:
      // TODO: we should always pluck out the id of the thing to zoom to
      // and then send it to this reducer
      return zoomReducer(state, action.blockKey);

    case INDENT:
      return { ...state,
        editorState: onTab(state.editorState, MAX_DEPTH, state.zoomedInItemId)
      };

    case DEDENT:
      return { ...state,
        editorState: onTab(state.editorState, MAX_DEPTH, state.zoomedInItemId, true)
      };

    case BOOKMARK:
      return { ...state,
        editorState: toggleBookmark(state.editorState, state.zoomedInItemId)
      };

    default:
      return state;
  }
}

function useDocumentTitle(editorState, zoomedInItemId) {
  const rootDocumentTitle = 'deepnotes - Note taking made easy. And deep.';
  React.useEffect(() => {
    if (zoomedInItemId === ROOT_KEY) {
      document.title = rootDocumentTitle;
    } else {
      const blockMap = editorState.getCurrentContent().getBlockMap();
      const zoomedInItemText = blockMap.get(zoomedInItemId).getText();
      document.title = zoomedInItemText;
    }
  }, [editorState, zoomedInItemId]);
}

// current and previous values. Like we do in componentDidUpdate with
// prevProps

function usePrevious(value) {
  // The ref object is a generic container whose current property is mutable ...
  // ... and can hold any value, similar to an instance property on a class
  const ref = React.useRef(undefined); // Store current value in ref

  React.useEffect(() => {
    ref.current = value;
  }, [value]); // Only re-run if value changes
  // Return previous value (happens before update in useEffect above)

  return ref.current;
}

/**
 * Find if parent or grandparent or some other ancestor in the tree is collapsed
 */
function hasCollapsedAntecedent(blockMap, blockKey, zoomedInItemId) {
  const collapsed = false;
  const block = blockMap.get(blockKey);

  if (!block) {
    return collapsed;
  }

  let parentBlock = blockMap.get(block.getIn(['data', 'parentId']));

  while (parentBlock) {
    if (zoomedInItemId && parentBlock.getKey() === zoomedInItemId) {
      break;
    }

    if (parentBlock.getIn(['data', 'collapsed'])) {
      return true;
    }

    parentBlock = blockMap.get(parentBlock.getIn(['data', 'parentId']));
  }

  return collapsed;
}

function blocksWithSanitizedPosAndDepthAndHasChildren(blockMap, node) {
  const nodeKey = node.getKey();
  const nodeDepth = node.getDepth();
  const children = blockMap.filter(b => !!(b && b.getIn(['data', 'parentId']) === nodeKey)).toArray().map((block, index) => {
    return block.setIn(['data', 'pos'], getPosNum(index + 1)).setIn(['data', 'hasChildren'], hasChildren(blockMap, block.getKey())).set('depth', nodeDepth + 1);
  });

  if (!children) {
    return [node];
  }

  return [node].concat(children.map(child => blocksWithSanitizedPosAndDepthAndHasChildren(blockMap, child)).flat());
}
/**
 * We have wrong pos information stored in the blocks some times. Don't know the root cause.
 * It causes many operations to behave in the wrong way. E.g. Dedent a child of an item with wrong pos causes the child item to move in an unpredictable manner.
 * move-up and move-down also start working weirdly.
 * So we sanitize or correct the pos information before we render anything.
 * The next time this data is saved, it's alright.
 * @param editorState
 */


function sanitizePosAndDepthInfo(editorState, rootKey) {
  const {
    blockMap
  } = pluckGoodies(editorState);

  if (!blockMap || blockMap.count() < 1) {
    return getEmptySlateState(ROOT_KEY);
  }

  const blocks = blocksWithSanitizedPosAndDepthAndHasChildren(blockMap, blockMap.get(rootKey));
  const newEditorState = draftJs.EditorState.createWithContent(draftJs.ContentState.createFromBlockArray(blocks), createDecorators());
  let selection;

  if (blocks.length > 1) {
    selection = draftJs.SelectionState.createEmpty(blocks[1].getKey());
  } else if (blocks.length > 0) {
    selection = draftJs.SelectionState.createEmpty(blocks[0].getKey());
  } else {
    return newEditorState;
  }

  return draftJs.EditorState.forceSelection(newEditorState, selection);
}

var styles$4 = {"container":"editor_styles-module_container__3H-_W","new-item-button":"editor_styles-module_new-item-button__3yUxz","new-item-icon":"editor_styles-module_new-item-icon__3-ZVX"};

function notADescendantOfZoomedInItem(editorState, block, zoomedInItemId) {
  const {
    blockMap
  } = pluckGoodies(editorState);
  const blockWithItsDescendants = getBlocksWithItsDescendants(blockMap, zoomedInItemId);
  return !blockWithItsDescendants.find(b => !!(b && b.getKey() === block.getKey()));
} // This is the key to a faster blockShouldBeHidden function
// TODO: Right now we are busting this cache on every render. We should find a way
// to only bust it if required. That is, only bust it if there's an operation which might
// spoil the data related to visibility.


let shouldBeHiddenCache = {};

function blockShouldBeHidden(editorState, block, zoomedInItemId, searchText) {
  const {
    blockMap
  } = pluckGoodies(editorState);
  const parentId = block.getIn(['data', 'parentId']);

  if (shouldBeHiddenCache[parentId] !== undefined) {
    // we set the hidden property of a zoomed in items parent also as hidden
    // But we want to show the zoomed in item itself
    return shouldBeHiddenCache[parentId] && block.getKey() !== zoomedInItemId;
  }

  const shouldBeHidden = block.getKey() === ROOT_KEY || // When zoomed in, anything below the zoomed in item level can be hidden
  block.getDepth() < blockMap.get(zoomedInItemId).getDepth() || block.getKey() !== zoomedInItemId && // we don't want to hide items inside collapsed parents if there is a
  // search text
  !searchText && hasCollapsedAntecedent(blockMap, block.getKey(), zoomedInItemId) || searchText && !block.getText().toLowerCase().includes(searchText.toLowerCase()) || notADescendantOfZoomedInItem(editorState, block, zoomedInItemId);

  if (block.getKey() !== ROOT_KEY) {
    shouldBeHiddenCache[parentId] = shouldBeHidden;

    if (shouldBeHidden) {
      shouldBeHiddenCache[block.getKey()] = shouldBeHidden;
    }
  }

  return shouldBeHidden;
}

const initialState = {
  loading: true,
  zoomedInItemId: ROOT_KEY,
  rootEditorState: /*#__PURE__*/getEmptySlateState(ROOT_KEY),
  editorState: /*#__PURE__*/getEmptySlateState(ROOT_KEY)
}; // TODO: let's try to also retain the selection state here
// Don't know if editor.getCurrentContent() has the selection state too. Should
// have

function forceUpdateEditorState(editorState, searchText = '') {
  // TODO - the below code ensures that our redo/undo stack is also maintained.
  // But do we care about it when we zoom into an item?
  const newEditorStateInstance = draftJs.EditorState.createWithContent(editorState.getCurrentContent(), createDecorators(searchText));
  return draftJs.EditorState.set(newEditorStateInstance, {
    selection: editorState.getSelection(),
    undoStack: editorState.getUndoStack(),
    redoStack: editorState.getRedoStack(),
    lastChangeType: editorState.getLastChangeType()
  });
} // Default maximum block depth supported by Draft.js CSS.


const DRAFT_DEFAULT_MAX_DEPTH = 4; // Default depth class prefix from Draft.js CSS.

const CUSTOM_DEPTH_CLASS = 'public-DraftStyleDefault-depth-deepnotes-';
const generateListNestingStyles = (selectorPrefix, maxDepth) => {
  let styles = `
.public-DraftStyleDefault-unorderedListItem:empty {
  display: none
}
`;

  for (let depth = 0; depth <= maxDepth; depth++) {
    const prefix = `${selectorPrefix}${depth}`;
    styles += `
.${prefix}.public-DraftStyleDefault-listLTR { 
list-style: none;
padding: 0;
margin: 0;
}
`;
  }

  return styles;
};
/**
 * Dynamically generates the right list nesting styles.
 * Can be wrapped as a pure component - to re-render only when `max` changes (eg. never).
 */

const ListNestingStyles = /*#__PURE__*/React.memo(props => {
  const {
    max
  } = props;
  return max > DRAFT_DEFAULT_MAX_DEPTH ? React.createElement("style", null, generateListNestingStyles(`${CUSTOM_DEPTH_CLASS}`, max)) : null;
});
ListNestingStyles.displayName = 'ListNestingStyles';
/**
 * Add depth classes that Draft.js doesn't provide.
 * See https://github.com/facebook/draft-js/blob/232791a4e92d94a52c869f853f9869367bdabdac/src/component/contents/DraftEditorContents-core.react.js#L58-L62.
 * @param {ContentBlock} block
 */

const blockDepthStyleFn = block => {
  const type = block.getType();

  if (type === 'unordered-list-item') {
    const depth = block.getDepth();
    const baseItemStyles = 'list-none m-0';
    return `${baseItemStyles} ${CUSTOM_DEPTH_CLASS}${String(depth)}`;
  }

  return '';
}; // for caching the object containing dispatch related functions
// otherwise the components accessing values from context rerender
// on every render

let editorDispatchContextValue = {};

function DeepnotesEditor(props) {
  // const [showBoardView, setShowBoardView] = React.useState(false);
  const searchInputRef = React.useRef(null);
  const editor = React.useRef(null); // using useReducer instead of multiple useState calls because this
  // is the top component and will probably have the global state with it.
  // useReducer will allow us to have logic to modify various parts of global
  // state in one place

  const [state, dispatch] = React.useReducer(rootReducer, // The second argument to useReducer can also be thought as the default
  // value of the state. From reducer perspective, it means the initial
  // value.
  initialState);
  const {
    searchText,
    initialEditorState,
    initialZoomedInItemId = ROOT_KEY,
    onChange,
    onRootChange,
    editorWrapperStyle,
    onBookmarkClick,
    withToolbar = true
  } = props;
  const {
    editorState,
    zoomedInItemId
  } = state;
  window.state = state;
  useDocumentTitle(editorState, zoomedInItemId);

  function setRootEditorState(editorState) {
    dispatch({
      type: SET_ROOT_EDITOR_STATE,
      editorState
    });
  }

  const setEditorState = React.useCallback(editorState => {
    dispatch({
      type: SET_EDITOR_STATE,
      editorState
    });
  }, [dispatch]);
  const expandParticularBlock = React.useCallback(blockKey => {
    dispatch({
      type: EXPAND_ITEM,
      blockKey
    });
  }, [dispatch]);
  const collapseParticularBlock = React.useCallback(blockKey => {
    dispatch({
      type: COLLAPSE_ITEM,
      blockKey
    });
  }, [dispatch]);
  const zoomTo = React.useCallback(blockKey => {
    dispatch({
      type: ZOOM,
      blockKey
    });

    if (typeof onRootChange === 'function') {
      onRootChange(blockKey);
    }
  }, [dispatch, onRootChange]); // load initial editorState from the owner props
  // React.useEffect(() => {
  // if (initialEditorState) {
  // const sanitizedInitialEditorState = sanitizePosAndDepthInfo(
  // initialEditorState,
  // ROOT_KEY
  // );
  // setRootEditorState(sanitizedInitialEditorState);
  // setEditorState(sanitizedInitialEditorState);
  // }
  // }, [initialEditorState, setEditorState]);
  // load initial editorState from the owner props

  React.useEffect(() => {
    if (zoomedInItemId !== initialZoomedInItemId) {
      zoomTo(initialZoomedInItemId);
    } // eslint-disable-next-line react-hooks/exhaustive-deps

  }, [zoomTo, initialZoomedInItemId]);
  const updateEditorState = React.useCallback(debounce((es, searchText) => {
    setEditorState(forceUpdateEditorState(es, searchText));
  }, SEARCH_DEBOUNCE), [setEditorState]);
  const previousSearchText = usePrevious(searchText);
  React.useEffect(() => {
    if (previousSearchText !== undefined && searchText !== previousSearchText) {
      updateEditorState(editorState, searchText);
    } // i don't want to run it if previousSearchText changes
    // eslint-disable-next-line react-hooks/exhaustive-deps

  }, [searchText]);
  React.useEffect(() => {
    if (typeof onChange === 'function') {
      onChange(editorState);
    } // Nope. Just nope.
    // eslint-disable-next-line react-hooks/exhaustive-deps

  }, [editorState]); // better to store in state rather than calculating in every render

  const baseDepth = editorState.getCurrentContent().getBlockMap().get(zoomedInItemId).getDepth();
  shouldBeHiddenCache = {};

  function blockRendererFn(contentBlock) {
    const type = contentBlock.getType();

    if (type === 'unordered-list-item') {
      return {
        component: Item,
        editable: true,
        // TODO: It would be better if we can remove the blockProps altogether
        props: {
          // TODO: Until we keep sending editorState to each Item, we can never memoize Item. editorState changes on every render.
          // If we can pass attach `hidden` information on each block when we create them, we won't have to send this at all
          zoomedInItemId: zoomedInItemId,
          baseDepth,
          searchText,
          hidden: blockShouldBeHidden(editorState, contentBlock, zoomedInItemId, searchText),
          onExpandClick: expandParticularBlock,
          onCollapseClick: collapseParticularBlock
        }
      };
    }

    return undefined;
  }

  function focusEditor() {
    // We don't want to refocus if it's already in focus
    if (editor && editor.current && editor.current.editor !== document.activeElement) {
      // when we are at root level, calling editor.current.focus() does not
      // work. Because the selection on editorState is set to the first block
      // by default
      // because we have 2 blocks when we initialize the editor. One root
      // block and another empty child block for the root. We do so in order
      // to have a consistent representation of a tree at all zoom levels.
      // But it breaks draft-js focus. So we have to manually focus the item
      // by using DOM selection and rane magic.
      // TODO: We can also try forcing selection to the 2nd block and setting the editorState in our state
      // Update: Which is what we did. Had to do it in multiple places
      // probably better to put a check in one place which says that if
      // the selection is on the root block, move it to the first block
      editor.current.focus();
    } else {
      console.log('Editor already in focus');
    }
  }

  React.useEffect(() => {
    setTimeout(() => {
      focusEditor();
    }, 100);
    window.addEventListener('keydown', e => {
      if (e && e.which === 27) {
        // esc key
        if (searchInputRef && searchInputRef.current) {
          searchInputRef.current.focus();
        }
      }

      if (e.metaKey && e.which === 191 && editor.current && editor.current.editor !== document.activeElement) {
        e.preventDefault();
        e.stopPropagation();
      }
    });

    if (initialEditorState) {
      const sanitizedInitialEditorState = sanitizePosAndDepthInfo(initialEditorState, ROOT_KEY);
      setRootEditorState(sanitizedInitialEditorState);
      setEditorState(sanitizedInitialEditorState);
    } // cleanup


    return () => {// TODO
    }; // eslint-disable-next-line
  }, []); // step 2. How do we have nested lists? When the user hits the tab key, we
  // want the current list item to become a sub item to the outer one
  // We can do that by using the onTab prop of the Editor
  // And then creating new state using RichUtils.onTab helper function
  // That function takes the current state, and increases the depth of the
  // 'unordered-list-item' by 1

  const handleTab = React.useCallback(event => {
    event.preventDefault();

    if (event.shiftKey) {
      dispatch({
        type: DEDENT
      });
    } else {
      dispatch({
        type: INDENT
      });
    }
  }, [dispatch]);
  const handleReturn = React.useCallback(event => {
    // alt+enter for marking item as complete. Works across platforms.
    if (event.altKey) {
      dispatch({
        type: INSERT_SOFT_NEWLINE
      });
      return 'handled';
    }

    return 'not-handled';
  }, [dispatch]);

  function keyBindingFn(e) {
    if (draftJs.KeyBindingUtil.hasCommandModifier(e) || draftJs.KeyBindingUtil.isCtrlKeyCommand(e)) {
      switch (e.keyCode) {
        case 191:
          // command+/
          // we are handling this shortcut in Editor even though we don't control showing/hiding of keyboard shortcut panel in the editor
          // draft-js has a default action of select-all for this shortcut
          return 'toggle-keyboard-shortcut-panel';

        case 38:
          // up arrow. Let's collapse the list
          // cmd+shift+up moves the list item up
          if (e.shiftKey) {
            return 'move-up';
          } else {
            return 'collapse-list';
          }

        case 40:
          // down arrow
          // cmd+shift+down moves the list item down
          if (e.shiftKey) {
            return 'move-down';
          } else {
            return 'expand-list';
          }

        case 190:
          // for Command+.
          return 'zoom-in';

        case 188:
          // for Command+,
          return 'zoom-out';

        case 13:
          // Command+enter
          return 'toggle-completion';

        case 222:
          // Command+'
          return 'go-to-home';

        case 8:
          // cmd+shift+backspace
          if (e.shiftKey) {
            return 'delete-item';
          } else {
            return draftJs.getDefaultKeyBinding(e);
          }

        default:
          return draftJs.getDefaultKeyBinding(e);
      }
    } else {
      if (e.keyCode === 9) {
        return handleTab(e);
      }
    }

    return draftJs.getDefaultKeyBinding(e);
  }

  function zoomIn() {
    const {
      anchorKey
    } = pluckGoodies(editorState);
    zoomTo(anchorKey);
  }

  function zoomOut() {
    // find the parent of the current zoomed in item, or nothing/root, if the
    // item zoomed in is a first level list item, and then set correct url
    const {
      editorState,
      zoomedInItemId
    } = state; // if there is no zoomed item, that means there's nothing to zoom out into
    // we are at the root

    if (!zoomedInItemId) {
      console.log('nothing is zoomed in so nothing to zoom out.');
      return;
    }

    const parentBlockOfZoomedInBlock = findParent(editorState, zoomedInItemId);

    if (parentBlockOfZoomedInBlock) {
      zoomTo(parentBlockOfZoomedInBlock.getKey());
    }
  }

  function collapse() {
    const {
      anchorKey
    } = pluckGoodies(state.editorState);

    if (anchorKey) {
      dispatch({
        type: COLLAPSE_ITEM,
        blockKey: anchorKey
      });
    }
  }

  function expand() {
    const {
      anchorKey
    } = pluckGoodies(state.editorState);

    if (anchorKey) {
      dispatch({
        type: EXPAND_ITEM,
        blockKey: anchorKey
      });
    }
  }

  const moveUp = React.useCallback(() => {
    dispatch({
      type: MOVE_UP
    });
  }, [dispatch]);
  const moveDown = React.useCallback(() => {
    dispatch({
      type: MOVE_DOWN
    });
  }, [dispatch]);
  const toggleCompletion = React.useCallback(() => {
    dispatch({
      type: TOGGLE_COMPLETION
    });
  }, [dispatch]);
  const goToHome = React.useCallback(() => {
    window.location.hash = '';
  }, []);
  const deleteCurrentItem = React.useCallback(() => {
    dispatch({
      type: DELETE_CURRENT_ITEM
    });
  }, [dispatch]);

  function handleKeyCommand(command) {
    switch (command) {
      case 'move-up':
        moveUp();
        return 'handled';

      case 'move-down':
        moveDown();
        return 'handled';

      case 'collapse-list':
        collapse();
        return 'handled';

      case 'expand-list':
        expand();
        return 'handled';
      // this is called when user presses the Enter or Return key

      case 'split-block':
        // TODO: this causes a major bug when the block to split is collapsed
        // The data inside the collapsed item vanishes
        // Which means, we need to implement our own split block :()
        // don't allow any new block creation when in search mode
        if (!searchText) {
          setEditorState(splitBlock(editorState, state.zoomedInItemId));
        }

        return 'handled';

      case 'zoom-in':
        zoomIn();
        return 'handled';

      case 'zoom-out':
        zoomOut();
        return 'handled';

      case 'toggle-completion':
        toggleCompletion();
        return 'handled';

      case 'backspace':
        // eslint-disable-next-line no-case-declarations
        const {
          contentState,
          blockMap,
          selectionState
        } = pluckGoodies(state.editorState); // eslint-disable-next-line no-case-declarations

        const block = blockMap.get(selectionState.getAnchorKey()); // if cursor is at the start of the list

        if (block.getText() === '' || selectionState.getAnchorOffset() === 0) {
          // 1. Don't allow deleting any non-leaf item this way. Causes other
          // problems. It's consistent with how workflowy does it too.
          // , don't do anything
          // 2. also don't do anything when this item is the only item in the
          // blockMap
          // 3. also don't delete first item in the list - that item will not have
          // any previous sibling
          // 4. first item in zoomed in state - key same as zoomedInItemId
          const pSibling = contentState.getBlockBefore(block.getKey());

          if (blockMap.get(selectionState.getAnchorKey()).getIn(['data', 'hasChildren']) || !pSibling || // accounting for every present ROOT block
          blockMap.count() === 2 || block.getKey() === state.zoomedInItemId) {
            return 'handled';
          } else {
            // else, delete the block
            // even if this item has children, they will either become the
            // previous siblings children or siblings
            return 'not-handled';
          }
        } else {
          return 'not-handled';
        }

      case 'go-to-home':
        goToHome();
        return 'handled';

      case 'delete-item':
        deleteCurrentItem();
        return 'handled';

      default:
        // eslint-disable-next-line no-case-declarations
        const newState = draftJs.RichUtils.handleKeyCommand(editorState, command);

        if (newState) {
          setEditorState(newState);
          return 'handled';
        }

        return 'not-handled';
    }
  }

  function handleChange(editorState) {
    const {
      contentState,
      anchorBlock,
      selectionState
    } = pluckGoodies(editorState);
    let newState = editorState; // if somehow a change takes users out of list item type, force the block
    // back to 'unordered-list-item' type

    if (anchorBlock && anchorBlock.getType() !== 'unordered-list-item') {
      const newContentState = draftJs.Modifier.setBlockType(contentState, selectionState, 'unordered-list-item'); // TODO: What should be the change type here?

      newState = draftJs.EditorState.push(editorState, newContentState, 'force-list-type');
    }

    dispatch({
      type: CHANGE,
      editorState: newState
    });
  }

  const handleIndentClick = React.useCallback(() => {
    dispatch({
      type: INDENT
    });
  }, [dispatch]);
  const handleOutdentClick = React.useCallback(() => {
    dispatch({
      type: DEDENT
    });
  }, [dispatch]); // TODO -
  // Adding search brings in a lot of complexity. What happens when users
  // searches something and then goes ahead and changes the filtered
  // list of items
  //    Ans - we can maintain a focus state for search input and only filter
  //    blocks when the search input is in focus
  // What happens if the search term is still there and user zooms out?
  //    Ans - maybe we can clean the search text on zoom out
  // When user searches something and then edits an item from the filtered
  // list, draft-js onChange now sends back the filtered blocks in the
  // changed editorState, which is what we store in our store. Which means
  // we lose the unfiltered data once users start editing filtered data.
  //    Ans - maintain another state variable called unfiltered data?
  //    Or, instead of filtering the blocks and sending to draft-js editor,
  //    just send the searchText to Item component and let it show/hide
  //    that item based on the searchText. Yesssss.
  // When user creates new item when in search mode. As soon as they type
  // something in that block, it disappears because it doesn't match the
  // search string. Can not let that happen by comparing the time stamps
  // of last search input change and block update timestamp. If the block
  // was created after the last search input was made, don't apply the
  // search filter on it.

  function handleAddNewItem() {
    // add new item to the end of the list
    // Make sure that it's at the end of the zoomed in list
    dispatch({
      type: SET_EDITOR_STATE,
      editorState: addEmptyBlockToEnd(state.editorState, zoomedInItemId, baseDepth + 1)
    });
  } // TODO: if we move this to our reducer, we can then cache using React.useCallback((), [dispatch])
  // set collapsed to false for every block


  const handleExpandAllClick = React.useCallback(() => {
    dispatch({
      type: EXPAND_ALL
    });
  }, [dispatch]); // keep calling collapseBlock for all the blocks
  // works like a charm

  const handleCollapseAllClick = React.useCallback(() => {
    dispatch({
      type: COLLAPSE_ALL
    });
  }, [dispatch]); // For times when user tabs through rest of the elements in our page
  // The editor itself will also be focusable

  function handleWrapperFocus() {
    focusEditor();
  }

  function handlePastedText(pastedText) {
    setEditorState(pasteText(editorState, pastedText));
    return 'handled';
  } // function handleshowboardviewclick() {
  //   if (zoomedInItemId !== ROOT_KEY) {
  //     console.log('board view activated');
  //     setShowBoardView(!showBoardView);
  //   } else {
  //     alert('Cannot show board view at root level');
  //   }
  // }
  // This is to cache the object we set as value for EditorDispatchContext
  // If we don't do this, we create a new object on every render
  // Which then rerenders every component accessing anything from the
  // EditorDispatchContext


  React.useEffect(() => {
    editorDispatchContextValue = {
      onZoom: zoomTo,
      onExpandClick: expandParticularBlock,
      onCollapseClick: collapseParticularBlock
    };
  }, [zoomTo, expandParticularBlock, collapseParticularBlock]);
  const handleBookmarkClick = React.useCallback(() => {
    dispatch({
      type: BOOKMARK
    });

    if (typeof onBookmarkClick === 'function') {
      onBookmarkClick();
    }
  }, [dispatch, onBookmarkClick]); // className="flex flex-col w-full p-10 pt-3 pl-6 mb-12 sm:pl-10 sm:shadow-sm rounded-md"

  return React.createElement("div", {
    className: "editor deepnotes-editor-theme-light"
  }, withToolbar && React.createElement(MenuContainer, {
    onExpandAllClick: handleExpandAllClick,
    onCollapseAllClick: handleCollapseAllClick,
    onIndentClick: handleIndentClick,
    onOutdentClick: handleOutdentClick,
    onToggleCompletionClick: toggleCompletion,
    isBookmarked: editorState && !!editorState.getCurrentContent().getBlockMap().get(zoomedInItemId).getIn(['data', 'bookmarked']),
    onBookmarkClick: handleBookmarkClick
  }), React.createElement("div", {
    className: styles$4.container,
    tabIndex: 0,
    onFocus: handleWrapperFocus,
    style: {
      minHeight: 300,
      ...editorWrapperStyle
    }
  }, React.createElement(EditorContext.Provider, {
    value: editorDispatchContextValue
  }, React.createElement(draftJs.Editor, {
    webDriverTestID: "dumpster-editor",
    textAlignment: "left",
    ref: editor,
    editorState: editorState,
    onChange: handleChange,
    blockRendererFn: blockRendererFn,
    handleReturn: handleReturn,
    handlePastedText: handlePastedText,
    stripPastedStyles: true,
    keyBindingFn: keyBindingFn,
    handleKeyCommand: handleKeyCommand,
    onFocus: () => console.log('editor got focus'),
    placeholder: "Start writing",
    blockStyleFn: blockDepthStyleFn,
    customStyleMap: {
      CODE: {
        color: '#15141f',
        background: '#eae9ed',
        fontFamily: 'Monaco,Menlo,Ubuntu Mono,Droid Sans Mono,Consolas,monospace',
        fontSize: '0.9em',
        padding: '0 0.25rem',
        margin: '0 0.0625rem',
        borderRadius: '0.125rem',
        overflowWrap: 'break-word',
        wordWrap: 'break-word'
      }
    }
  }), React.createElement(ListNestingStyles, {
    max: 40
  })), React.createElement("button", {
    className: classNames(buttonStyles['button'], buttonStyles['icon-button'], styles$4['new-item-button']),
    onClick: handleAddNewItem,
    "aria-label": "Add new item",
    title: "Add new item"
  }, React.createElement(PlusSign, {
    className: styles$4['new-item-icon'],
    "aria-label": "Add new item"
  }))));
}

var Editor = /*#__PURE__*/React.memo(DeepnotesEditor);

exports.ROOT_KEY = ROOT_KEY;
exports.createDecorators = createDecorators;
exports.default = Editor;
exports.findParent = findParent;
exports.pluckGoodies = pluckGoodies;
//# sourceMappingURL=deepnotes-editor.cjs.development.js.map
