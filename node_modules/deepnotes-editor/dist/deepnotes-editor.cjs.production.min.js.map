{"version":3,"file":"deepnotes-editor.cjs.production.min.js","sources":["../src/Editor/components/EditorDispatchContext.ts","../src/icons/CheckMark.tsx","../src/icons/ArrowRight.tsx","../src/icons/ArrowLeft.tsx","../src/icons/DotHorizontal.tsx","../src/icons/Star.tsx","../src/Editor/components/Menu.tsx","../src/Editor/components/Hashtag.tsx","../src/Editor/components/SearchHighlight.tsx","../src/Editor/components/Link.tsx","../src/Editor/decorators.ts","../src/Editor/pluck_goodies.ts","../src/constants.ts","../src/Editor/pos_generators.ts","../src/Editor/block_creators.ts","../src/Editor/calculate_depth.ts","../src/Editor/tree_utils.ts","../src/Editor/add_empty_block_to_end.ts","../src/Editor/recreate_parent_block_map.ts","../src/Editor/start_and_end_keys.ts","../src/Editor/make_corrections_to_node_and_its_descendants.ts","../src/Editor/find_parent.ts","../src/icons/DownArrow.tsx","../src/Editor/components/Disc.tsx","../src/icons/PlusSign.tsx","../src/icons/MinusSign.tsx","../src/Editor/components/Item.tsx","../src/Editor/move.ts","../src/Editor/collapse_expand_block.ts","../src/Editor/tab.ts","../src/Editor/state_manager.ts","../src/Editor/components/Editor.tsx","../src/Editor/has_collapsed_antecedent.ts","../src/hooks/document-title.ts","../src/debounce.ts","../src/hooks/previous.ts","../src/Editor/sanitize_pos_and_depth_info.ts","../src/Editor/paste_text.ts","../src/Editor/split_block.ts"],"sourcesContent":["import * as React from 'react';\n\nexport interface EditorDispatchContextProps {\n  onZoom: (key: string) => void;\n  onExpandClick: (key: string) => void;\n  onCollapseClick: (key: string) => void;\n}\n\n/**\n * We will only put the dispatch function in this context\n * The dispatch value from useReducer never changes after it's first created\n * Which means the components which access the dispatch functions from this context\n * will never uncessarily rerender on other state changes not related to them\n */\nexport const EditorContext = React.createContext<\n  Partial<EditorDispatchContextProps>\n>({});\n","import * as React from 'react';\n\nexport default function CheckMark(props: React.SVGProps<SVGSVGElement>) {\n  return (\n    <svg\n      fill=\"none\"\n      strokeLinecap=\"round\"\n      strokeLinejoin=\"round\"\n      strokeWidth={2}\n      viewBox=\"0 0 24 24\"\n      stroke=\"currentColor\"\n      {...props}\n    >\n      <path d=\"M5 13l4 4L19 7\" />\n    </svg>\n  );\n}\n","import * as React from 'react';\n\nexport default function ArrowRight(props: React.SVGProps<SVGSVGElement>) {\n  return (\n    <svg\n      fill=\"none\"\n      strokeLinecap=\"round\"\n      strokeLinejoin=\"round\"\n      strokeWidth={2}\n      viewBox=\"0 0 24 24\"\n      stroke=\"currentColor\"\n      {...props}\n    >\n      <path d=\"M17 8l4 4m0 0l-4 4m4-4H3\" />\n    </svg>\n  );\n}\n","import * as React from 'react';\n\nexport default function ArrowLeft(props: React.SVGProps<SVGSVGElement>) {\n  return (\n    <svg\n      fill=\"none\"\n      strokeLinecap=\"round\"\n      strokeLinejoin=\"round\"\n      strokeWidth={2}\n      viewBox=\"0 0 24 24\"\n      stroke=\"currentColor\"\n      {...props}\n    >\n      <path d=\"M7 16l-4-4m0 0l4-4m-4 4h18\" />\n    </svg>\n  );\n}\n","import * as React from 'react';\n\nexport default function DotHorizontal(props: React.SVGProps<SVGSVGElement>) {\n  return (\n    <svg\n      fill=\"none\"\n      strokeLinecap=\"round\"\n      strokeLinejoin=\"round\"\n      strokeWidth={2}\n      viewBox=\"0 0 24 24\"\n      stroke=\"currentColor\"\n      {...props}\n    >\n      <path d=\"M5 12h.01M12 12h.01M19 12h.01M6 12a1 1 0 11-2 0 1 1 0 012 0zm7 0a1 1 0 11-2 0 1 1 0 012 0zm7 0a1 1 0 11-2 0 1 1 0 012 0z\" />\n    </svg>\n  );\n}\n","import * as React from 'react';\n\nexport default function Star(props: React.SVGProps<SVGSVGElement>) {\n  return (\n    <svg\n      fill=\"none\"\n      strokeLinecap=\"round\"\n      strokeLinejoin=\"round\"\n      strokeWidth={1}\n      viewBox=\"0 0 24 24\"\n      stroke=\"currentColor\"\n      {...props}\n    >\n      <path d=\"M11.049 2.927c.3-.921 1.603-.921 1.902 0l1.519 4.674a1 1 0 00.95.69h4.915c.969 0 1.371 1.24.588 1.81l-3.976 2.888a1 1 0 00-.363 1.118l1.518 4.674c.3.922-.755 1.688-1.538 1.118l-3.976-2.888a1 1 0 00-1.176 0l-3.976 2.888c-.783.57-1.838-.197-1.538-1.118l1.518-4.674a1 1 0 00-.363-1.118l-3.976-2.888c-.784-.57-.38-1.81.588-1.81h4.914a1 1 0 00.951-.69l1.519-4.674z\" />\n    </svg>\n  );\n}\n","import * as React from 'react';\nimport classNames from 'classnames';\nimport { Menu, MenuList, MenuButton, MenuItem } from '@reach/menu-button';\n\nimport CheckMark from '../../icons/CheckMark';\nimport ArrowRight from '../../icons/ArrowRight';\nimport ArrowLeft from '../../icons/ArrowLeft';\nimport DotHorizontal from '../../icons/DotHorizontal';\nimport Star from '../../icons/Star';\n\nimport styles from './menu_styles.module.css';\nimport buttonStyles from '../../button_styles.module.css';\nimport '@reach/menu-button/styles.css';\n\ninterface Props {\n  onExpandAllClick: () => void;\n  onCollapseAllClick: () => void;\n  onIndentClick: () => void;\n  onOutdentClick: () => void;\n  onToggleCompletionClick: () => void;\n  isBookmarked: boolean;\n  onBookmarkClick: () => void;\n}\n\nexport default function MenuContainer({\n  onExpandAllClick,\n  onCollapseAllClick,\n  onIndentClick,\n  onOutdentClick,\n  onToggleCompletionClick,\n  isBookmarked,\n  onBookmarkClick,\n}: Props) {\n  return (\n    <div className={styles['menu-container']}>\n      <div className={styles['menu-left-container']}>\n        <button\n          onMouseDown={e => {\n            // tip: mousedown event occurs before onFocus and onClick. If we\n            // stop the propagation event in mousedown, the onFocus and onClick\n            // events are not triggered. This means the editor item never loses\n            // focus. This helps prevent the on screen keyboard to not hide on\n            // mobile devices\n            e.stopPropagation();\n            e.preventDefault();\n            e.nativeEvent.stopImmediatePropagation();\n            onToggleCompletionClick();\n          }}\n          aria-label=\"Mark complete\"\n          className={classNames(\n            buttonStyles['icon-button'],\n            buttonStyles['button']\n          )}\n          title=\"Mark complete\"\n        >\n          <CheckMark className={styles['menu-icon']} />\n        </button>\n        {'\\u00A0'}\n        <button\n          onMouseDown={e => {\n            // tip: mousedown event occurs before onFocus and onClick. If we\n            // stop the propagation event in mousedown, the onFocus and onClick\n            // events are not triggered. This means the editor item never loses\n            // focus. This helps prevent the on screen keyboard to not hide on\n            // mobile devices\n            e.stopPropagation();\n            e.preventDefault();\n            e.nativeEvent.stopImmediatePropagation();\n            onOutdentClick();\n          }}\n          aria-label=\"Outdent\"\n          className={classNames(\n            buttonStyles['icon-button'],\n            buttonStyles['button']\n          )}\n          title=\"Outdent\"\n        >\n          <ArrowLeft className={styles['menu-icon']} />\n        </button>\n        <button\n          onMouseDown={e => {\n            e.stopPropagation();\n            e.preventDefault();\n            e.nativeEvent.stopImmediatePropagation();\n            onIndentClick();\n          }}\n          aria-label=\"Indent\"\n          className={classNames(\n            buttonStyles['icon-button'],\n            buttonStyles['button']\n          )}\n          title=\"Indent\"\n        >\n          <ArrowRight className={styles['menu-icon']} />\n        </button>\n      </div>\n      <div className={styles['menu-right-container']}>\n        <button\n          className={classNames(\n            buttonStyles['icon-button'],\n            buttonStyles['button']\n          )}\n          style={{ marginRight: '1rem' }}\n          onMouseDown={e => {\n            e.stopPropagation();\n            e.preventDefault();\n            e.nativeEvent.stopImmediatePropagation();\n            onBookmarkClick();\n          }}\n          aria-label=\"Bookmark item\"\n          title=\"Bookmark item\"\n          data-bookmarked={isBookmarked}\n        >\n          <Star\n            className={classNames(styles['menu-icon-large'], {\n              [styles.bookmarked]: isBookmarked,\n              [styles['not-bookmarked']]: !isBookmarked,\n            })}\n          />\n        </button>\n        <Menu>\n          {() => (\n            <>\n              <MenuButton>\n                <button\n                  className={classNames(\n                    buttonStyles['icon-button'],\n                    buttonStyles['button']\n                  )}\n                  aria-label=\"Show menu\"\n                >\n                  <DotHorizontal className={styles['menu-icon']} />\n                </button>\n              </MenuButton>\n              <MenuList className={styles['slide-down']}>\n                <MenuItem onSelect={onExpandAllClick}>Expand all</MenuItem>\n                <MenuItem onSelect={onCollapseAllClick}>Collapse all</MenuItem>\n              </MenuList>\n            </>\n          )}\n        </Menu>\n      </div>\n    </div>\n  );\n}\n","import * as React from 'react';\n\ninterface Props {\n  children: Array<React.ReactElement>;\n  handleSearchInputChange?: (searchText: string) => void;\n}\n\nfunction Hashtag({ children, handleSearchInputChange }: Props) {\n  return (\n    <button\n      style={{\n        textDecoration: 'underline',\n        color: 'rgb(134, 140, 144)',\n        cursor: 'pointer',\n      }}\n      onClick={() => {\n        if (\n          children[0] &&\n          children[0].props &&\n          children[0].props.text &&\n          handleSearchInputChange\n        ) {\n          handleSearchInputChange(children[0].props.text);\n        }\n      }}\n      data-testid=\"hashtag\"\n    >\n      {children}\n    </button>\n  );\n}\n\nexport default React.memo(Hashtag);\n","import * as React from 'react';\n\ninterface Props {\n  children: React.ReactNode | React.ReactNodeArray;\n}\n\nexport default function SearchHighlight(props: Props) {\n  return (\n    <span style={{ background: 'rgb(255,230,153)' }}>{props.children}</span>\n  );\n}\n","import * as React from 'react';\n\nimport styles from './link_styles.module.css';\n\ninterface Props {\n  children: Array<React.ReactElement>;\n}\n\nexport default function Link(props: Props) {\n  const link = React.Children.map(props.children, (child: React.ReactElement) =>\n    child && child.props ? child.props.text : ''\n  ).join('');\n\n  return (\n    <a\n      href={link}\n      onClick={() => window.open(link, '_blank')}\n      className={styles.link}\n    >\n      {props.children}\n    </a>\n  );\n}\n","import linkify from 'linkify-it';\nimport memoizeOne from 'memoize-one';\nimport { ContentBlock, CompositeDecorator } from 'draft-js';\nimport escapeStringRegexp from 'escape-string-regexp';\n\nimport Hashtag from './components/Hashtag';\nimport SearchHighlight from './components/SearchHighlight';\nimport Link from './components/Link';\n\nconst linkifyInstance = linkify();\nconst HASHTAG_REGEX = /#[\\w\\u0590-\\u05ff]+/g;\n\ntype Callback = (start: number, end: number) => void;\n\nfunction findWithRegex(\n  regex: RegExp,\n  contentBlock: ContentBlock,\n  callback: Callback\n) {\n  const text = contentBlock.getText();\n  let matchArr, start;\n  while ((matchArr = regex.exec(text)) !== null) {\n    start = matchArr.index;\n    callback(start, start + matchArr[0].length);\n  }\n}\n\nfunction hashtagStrategy(contentBlock: ContentBlock, callback: Callback) {\n  findWithRegex(HASHTAG_REGEX, contentBlock, callback);\n}\n\nfunction findLinkEntities(\n  contentBlock: ContentBlock,\n  callback: (start: number, end: number) => void\n) {\n  const links = linkifyInstance.match(contentBlock.getText());\n  if (links) {\n    links.forEach((link: any) => callback(link.index, link.lastIndex));\n  }\n}\n\nexport const createDecorators = memoizeOne((searchText = '') => {\n  const regex = new RegExp(escapeStringRegexp(searchText), 'gi');\n\n  return new CompositeDecorator([\n    {\n      strategy: hashtagStrategy,\n      component: Hashtag,\n    },\n    {\n      strategy: (contentBlock, callback) => {\n        if (searchText) {\n          findWithRegex(regex, contentBlock, callback);\n        }\n      },\n      component: SearchHighlight,\n    },\n    { strategy: findLinkEntities, component: Link },\n  ]);\n});\n","import { EditorState } from 'draft-js';\n\nexport default function pluckGoodies(editorState: EditorState) {\n  const contentState = editorState.getCurrentContent();\n  const selectionState = editorState.getSelection();\n  const blockMap = contentState.getBlockMap();\n  const anchorKey = selectionState.getAnchorKey();\n  const anchorBlock = contentState.getBlockForKey(anchorKey);\n  const focusKey = selectionState.getFocusKey();\n  const focusBlock = contentState.getBlockForKey(focusKey);\n\n  return {\n    contentState,\n    selectionState,\n    blockMap,\n    anchorKey,\n    anchorBlock,\n    focusKey,\n    focusBlock,\n  };\n}\n","export const LOCAL_STORAGE_KEY = 'dumpster_content';\nexport const ROOT_KEY = 'root';\nexport const BASE_POS = 100000;\nexport const DB_NAME = 'deepnotes';\nexport const BLOCKS_TABLE_NAME = 'blocks';\nexport const DROPBOX_AUTOSAVE_PREF_KEY = 'DROPBOX_AUTOSAVE_PREF_KEY';\nexport const USER_PREF_SHOW_KEYBOARD_SHORTCUT_PANEL =\n  'USER_PREF_SHOW_KEYBOARD_SHORTCUT_PANEL';\nexport const USER_PREF_SHOW_SIDEBAR = 'USER_PREF_SHOW_SIDEBAR';\nexport const USER_PREF_THEME = 'USER_PREF_THEME';\nexport const MAX_DEPTH = 1000;\nexport const THEME_DARK = 'theme-dark';\nexport const THEME_LIGHT = 'theme-light';\n// i came to the 250 millisecond value by trial and error. The search\n// responsiveness still fill a little slow but if i reduce it further, there\n// will be to much rerender of the whole editor\nexport const SEARCH_DEBOUNCE = 250;\n","import { BASE_POS } from '../constants';\n\nexport function getPosNum(pos: number) {\n  return pos * BASE_POS;\n}\n\nexport function getPosInBetween(posStart: number, posEnd: number) {\n  return Math.round((posStart + posEnd) / 2);\n}\n\nexport function getPosAfter(lastPos: number) {\n  return lastPos + BASE_POS;\n}\n","import Immutable, { List } from 'immutable';\nimport {\n  CharacterMetadata,\n  ContentBlock,\n  EditorState,\n  ContentState,\n  genKey,\n  SelectionState,\n} from 'draft-js';\n\nimport { getPosNum } from './pos_generators';\nimport { createDecorators } from './decorators';\n\ninterface ContentBlockConfig {\n  key: string;\n  text: string;\n  depth: number;\n  characterList: List<CharacterMetadata>;\n}\n\nexport function getNewContentBlock(config: Partial<ContentBlockConfig>) {\n  return new ContentBlock({\n    key: genKey(),\n    type: 'unordered-list-item',\n    text: '',\n    depth: 0,\n    ...config,\n  });\n}\n\nexport function getEmptyBlock() {\n  return getNewContentBlock({ text: '' });\n}\n\nexport function getRootBlock(rootId: string) {\n  return getNewContentBlock({ text: '', key: rootId });\n}\n\nexport function getEmptySlateState(rootId: string) {\n  const firstItem = getEmptyBlock()\n    .set('depth', 1)\n    .set(\n      'data',\n      Immutable.Map({ parentId: rootId, pos: getPosNum(1) })\n    ) as ContentBlock;\n  const rootBlock = getRootBlock(rootId);\n  // we add 2 blocks in our empty slate because\n  // if we add only the root block, draftjs will then allow editing of the\n  // root block item.\n  // That problem goes away when i set the zoomedInItemId as 'root'. Hmm.\n  // But then there's no starting item to work with. Which is why we need\n  // the second empty block\n  const firstBlocks = [rootBlock, firstItem];\n\n  // // How to get started with a list item by default\n  // // Which is what workflowy does\n  // // Just call RichUtils.toggleBlockType with the empty state we create at\n  // // the beginning with 'unordered-list-item'\n  // RichUtils.toggleBlockType(EditorState.createEmpty(), \"unordered-list-item\")\n  // );\n  let emptySlate = EditorState.createWithContent(\n    ContentState.createFromBlockArray(firstBlocks),\n    createDecorators()\n  );\n  emptySlate = EditorState.forceSelection(\n    emptySlate,\n    SelectionState.createEmpty(firstItem.getKey())\n  );\n\n  return emptySlate;\n}\n","import { BlockMap } from 'draft-js';\n\nexport function calculateDepth(\n  blockMap: BlockMap,\n  blockKey: string,\n  zoomedInItemId?: string\n) {\n  let depth = -1;\n  const block = blockMap.get(blockKey);\n\n  if (!block) {\n    return depth;\n  }\n\n  let parentBlock = blockMap.get(block.getIn(['data', 'parentId']));\n\n  while (parentBlock) {\n    if (zoomedInItemId && parentBlock.getKey() === zoomedInItemId) {\n      break;\n    }\n\n    depth += 1;\n    parentBlock = blockMap.get(parentBlock.getIn(['data', 'parentId']));\n  }\n\n  return depth;\n}\n","import * as Immutable from 'immutable';\nimport { BlockMap, ContentBlock } from 'draft-js';\n\nimport { calculateDepth } from './calculate_depth';\n\n// Warning: This function is very expensive. Don't use it for regular, repetitive operations.\n// Only use for one time operations like at the start of load, or while saving etc.\n// We are using it currently to add hasChildren information to a block when we initialize\n// the editor\nexport function hasChildren(blockMap: BlockMap, blockKey: string): boolean {\n  return !!blockMap.find(\n    b => !!(b && b.getIn(['data', 'parentId']) === blockKey)\n  );\n}\n\nexport function adjustHasChildren(blockMap: BlockMap, blockKey: string) {\n  const block = blockMap.get(blockKey);\n\n  return blockMap.set(\n    blockKey,\n    block.setIn(\n      ['data', 'hasChildren'],\n      hasChildren(blockMap, blockKey)\n    ) as ContentBlock\n  ) as BlockMap;\n}\n\n// TODO: Is it a better idea to get all children, sortByPos, and then return the first block?\n// right now, we are relying on the fact that draft-js blocks are sorted by the order they appear in\nexport function getFirstChild(\n  blockMap: BlockMap,\n  blockKey: string\n): ContentBlock | undefined {\n  return blockMap.find(\n    b => !!(b && b.getIn(['data', 'parentId']) === blockKey)\n  );\n}\n\nexport function getChildren(blockMap: BlockMap, blockKey: string) {\n  return blockMap.filter(\n    b => !!(b && b.getIn(['data', 'parentId']) === blockKey)\n  );\n}\n\nexport function getNextSibling(blockMap: BlockMap, blockKey: string) {\n  const block = blockMap.get(blockKey);\n  const parentId = block.getIn(['data', 'parentId']);\n\n  return blockMap\n    .filter(b => !!(b && b.getIn(['data', 'parentId']) === parentId))\n    .find(\n      b => !!(b && b.getIn(['data', 'pos']) > block.getIn(['data', 'pos']))\n    );\n}\n\nexport function getPreviousSibling(blockMap: BlockMap, blockKey: string) {\n  const block = blockMap.get(blockKey);\n  const parentId = block.getIn(['data', 'parentId']);\n\n  return blockMap\n    .filter(b => !!(b && b.getIn(['data', 'parentId']) === parentId))\n    .reverse()\n    .find(\n      b => !!(b && b.getIn(['data', 'pos']) < block.getIn(['data', 'pos']))\n    );\n}\n\n/**\n * It returns block with all it's descendants, not just it's children\n * Everything inside tree with the block as the root node\n * @param blockMap\n * @param blockKey\n */\nexport function getBlocksWithItsDescendants(\n  blockMap: BlockMap,\n  blockKey: string\n): Immutable.Iterable<string, ContentBlock> {\n  const block = blockMap.get(blockKey);\n\n  return blockMap\n    .toSeq()\n    .skipUntil((_, k) => k === blockKey)\n    .takeWhile(\n      (b, k) =>\n        !!(\n          b &&\n          (k === blockKey ||\n            calculateDepth(blockMap, b.getKey()) >\n              calculateDepth(blockMap, block.getKey()))\n        )\n    );\n}\n","import { OrderedMap } from 'immutable';\nimport {\n  EditorState,\n  ContentState,\n  SelectionState,\n  ContentBlock,\n  BlockMap,\n} from 'draft-js';\n\nimport pluckGoodies from './pluck_goodies';\nimport { getNewContentBlock } from './block_creators';\nimport { getBlocksWithItsDescendants } from './tree_utils';\nimport { getPosNum, getPosAfter } from './pos_generators';\n\n// TODO: Should instead use recreateParentBlockMap\nfunction insertBlocksAtKey(\n  blockMap: BlockMap,\n  blocksToInsert: Immutable.Iterable<string, ContentBlock>,\n  insertionBlockKey: string,\n  insertBefore: boolean\n) {\n  const insertionBlock = blockMap.get(insertionBlockKey);\n  const blocksBeforeInsertionPoint = blockMap\n    .toSeq()\n    .takeUntil((_, k) => k === insertionBlockKey);\n  const blocksAfterInsertionPoint = blockMap\n    .toSeq()\n    .skipUntil((_, k) => k === insertionBlockKey)\n    .rest();\n\n  if (insertBefore) {\n    return blocksBeforeInsertionPoint\n      .concat(blocksToInsert)\n      .concat([[insertionBlockKey, insertionBlock]])\n      .concat(blocksAfterInsertionPoint)\n      .toOrderedMap();\n  } else {\n    return blocksBeforeInsertionPoint\n      .concat([[insertionBlockKey, insertionBlock]])\n      .concat(blocksToInsert)\n      .concat(blocksAfterInsertionPoint)\n      .toOrderedMap();\n  }\n}\n\nfunction insertBlocksAfter(\n  blockMap: BlockMap,\n  blocks: Immutable.Iterable<string, ContentBlock>,\n  insertionBlockKey: string\n) {\n  return insertBlocksAtKey(blockMap, blocks, insertionBlockKey, false);\n}\n\n/**\n * Will add a child to the given parentBlockKey after all of it's children.\n * If the parentBlockKey has no children, it will create a new child and add\n * that.\n */\nfunction appendChild(\n  blockMap: BlockMap,\n  parentBlockKey: string,\n  blockToAdd: ContentBlock\n) {\n  const blockWithItsChildren = getBlocksWithItsDescendants(\n    blockMap,\n    parentBlockKey\n  );\n\n  let blockToInsertAfterKey = parentBlockKey;\n  const parentId = parentBlockKey;\n  let pos = getPosNum(1);\n  // if the block has some children\n  if (blockWithItsChildren && blockWithItsChildren.count() > 1) {\n    blockToInsertAfterKey = blockWithItsChildren.last().getKey();\n    pos = getPosAfter(blockWithItsChildren.last().getIn(['data', 'pos']));\n  }\n\n  return insertBlocksAfter(\n    blockMap,\n    OrderedMap({\n      [blockToAdd.getKey()]: blockToAdd\n        .setIn(['data', 'parentId'], parentId)\n        .setIn(['data', 'pos'], pos) as ContentBlock,\n    }),\n    blockToInsertAfterKey\n  );\n}\n\n/**\n * Adds an empty block to the end of the list\n * If we are in a zoomed in state, we should add the block to the end of the\n * children list for the zoomedin item\n */\nexport function addEmptyBlockToEnd(\n  editorState: EditorState,\n  zoomedInItemId: string,\n  depth: number\n) {\n  const { contentState, blockMap } = pluckGoodies(editorState);\n  const newBlock = getNewContentBlock({ depth });\n  let newBlockMap;\n\n  // if we are at the root level, we can simply add the block to end of list\n  if (!zoomedInItemId) {\n    newBlockMap = blockMap.set(newBlock.getKey(), newBlock);\n  } else {\n    // otherwise we need to add the block to end of children list of the zoomed\n    // in item. There can be 2 cases here\n    // 1. The zoomed in item already has children\n    // 2. The zoomed in item does not have any children\n    // In this case, we can add the block after the zoomedin item and then call\n    // onTab, which will make that block the zoomed in items child\n    // OR - let's just write a appendChild method which takes care of both cases\n    // internally\n    newBlockMap = appendChild(blockMap, zoomedInItemId, newBlock);\n  }\n\n  const newSelection = SelectionState.createEmpty(newBlock.getKey());\n\n  const newContentState = contentState.merge({\n    blockMap: newBlockMap,\n    selectionBefore: newSelection,\n    selectionAfter: newSelection.merge({\n      anchorKey: newBlock.getKey(),\n      anchorOffset: 0,\n      focusKey: newBlock.getKey(),\n      focusOffset: 0,\n    }),\n  }) as ContentState;\n\n  // Always, always use this method to modify editorState when in doubt about\n  // how to edit the editor state. It maintains the undo/redo stack for the\n  // stack - https://draftjs.org/docs/api-reference-editor-state#push\n  return EditorState.forceSelection(\n    EditorState.push(editorState, newContentState, 'add-new-item' as any),\n    newSelection\n  );\n}\n","import { ContentState, BlockMap, SelectionState } from 'draft-js';\n\nimport { getStartAndEndKeys } from './start_and_end_keys';\nimport { makeCorrectionsToNodeAndItsDescendants } from './make_corrections_to_node_and_its_descendants';\n\n/**\n * This function is super important for many edge cases of dedents\n * When an item in the middle of it's siblings is dedented, we can'j just\n * dedent that item and leave it there. It implies all it's siblings which\n * come after it will become it's children, which we don't want.\n * Just changing the parentId and pos of the dedented item means the data is\n * now correct, but the position of the block in our blockMap is not correct.\n * So we take the whole block of the dedented blocks new parent and regenrate\n * it based on the new parentId and pos data. That automatically puts the\n * dedented block in it's right place in the blockMap\n * TODO: This operation might be slow. Measure it's performance and tweak\n * it if required.\n * TODO: It does not work if the blocks are already not in correct position\n * E.g. I can't just set the parentId of some block to something new and\n * recreateParentBlockMap for that parentId and expect the block to be a child\n * of that new parent. Can we think of a way make sure that all items which\n * are supposed to be inside the given parentId are there?\n */\nexport function recreateParentBlockMap(\n  contentState: ContentState,\n  blockMap: BlockMap,\n  parentId: string\n): BlockMap {\n  const selectionState = SelectionState.createEmpty(parentId);\n  const [startKey, endKey] = getStartAndEndKeys(contentState, selectionState);\n  const startIndex = blockMap.keySeq().findIndex(k => k === startKey);\n  const endIndex = blockMap.keySeq().findIndex(k => k === endKey);\n\n  // the main thing nodeWithItsChildren does is sort the children inside a parent by it's pos. We rely on that to ensure that the sorting is correct after we set change the pos of some block\n  const recreatedContentState = ContentState.createFromBlockArray(\n    makeCorrectionsToNodeAndItsDescendants(blockMap, blockMap.get(parentId))\n  );\n  const recreatedBlocks = recreatedContentState.getBlockMap();\n\n  const recreatedBlockMap = blockMap\n    .slice(0, startIndex)\n    .concat(recreatedBlocks, blockMap.slice(endIndex + 1)) as BlockMap;\n\n  return recreatedBlockMap;\n}\n","import { ContentState, SelectionState } from 'draft-js';\n\nimport { getBlocksWithItsDescendants } from './tree_utils';\n\n/**\n * This is not a generic start and end keys function\n * It's very specific in that it finds the first item which is either a sibling\n * of the start item or higher than that. I.e. it finds all the children of the\n * first item\n * TODO: Can't we reuse getBlocksWithItsChildren here?\n */\nexport function getStartAndEndKeys(\n  contentState: ContentState,\n  selectionState: SelectionState\n) {\n  const startBlockKey = selectionState.getAnchorKey();\n  const blockWithItsChildren = getBlocksWithItsDescendants(\n    contentState.getBlockMap(),\n    startBlockKey\n  );\n\n  return [\n    blockWithItsChildren.first().getKey(),\n    blockWithItsChildren.last().getKey(),\n  ];\n}\n","import { BlockMap, ContentBlock } from 'draft-js';\n\nfunction sortByPos(arr: Array<ContentBlock>) {\n  const newArr = [...arr];\n\n  newArr.sort((item1, item2) => {\n    // @ts-ignore\n    return item1.getIn(['data', 'pos']) - item2.getIn(['data', 'pos']);\n  });\n\n  return newArr;\n}\n\n/**\n * Given a blockMap and a block id, this function traverses the tree from the given block id and returns all blocks under that tree\n * It makes some changes to the children as it traverses them\n *  1. It sorts the children by pos\n *  2. It updates the depth information\n */\nexport function makeCorrectionsToNodeAndItsDescendants(\n  blockMap: BlockMap,\n  node: ContentBlock\n): Array<ContentBlock> {\n  const nodeDepth = node.getDepth();\n  const nodeKey = node.getKey();\n\n  const children = sortByPos(\n    blockMap\n      .filter(b => !!(b && b.getIn(['data', 'parentId']) === nodeKey))\n      .map((b?: ContentBlock) => {\n        return (b ? b.set('depth', nodeDepth + 1) : b) as ContentBlock;\n      })\n      .toArray()\n  );\n\n  // termination condition. The node is a leaf node.\n  if (!children) {\n    return [node];\n  }\n\n  return [node].concat(\n    children\n      .map((child: ContentBlock) =>\n        makeCorrectionsToNodeAndItsDescendants(blockMap, child)\n      )\n      .flat()\n  );\n}\n","import { EditorState } from 'draft-js';\n\nimport pluckGoodies from './pluck_goodies';\nimport { calculateDepth } from './calculate_depth';\n\nexport function findParent(editorState: EditorState, blockKey: string) {\n  const { blockMap } = pluckGoodies(editorState);\n  const block = blockMap.get(blockKey);\n\n  const parentBlock = blockMap\n    .toSeq()\n    .takeUntil((_, k) => k === blockKey)\n    .reverse()\n    .skipWhile(\n      b =>\n        !!(\n          b &&\n          calculateDepth(blockMap, b.getKey()) >=\n            calculateDepth(blockMap, block.getKey())\n        )\n    )\n    .first();\n\n  return parentBlock;\n}\n","import * as React from 'react';\n\nexport default function DownArrow(props: React.SVGProps<SVGSVGElement>) {\n  return (\n    <svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 24 24\" {...props}>\n      <path d=\"M12 21l-12-18h24z\" />\n    </svg>\n  );\n}\n","import * as React from 'react';\nimport classNames from 'classnames';\n\nimport { EditorContext } from './EditorDispatchContext';\nimport DownArrow from '../../icons/DownArrow';\n\nimport styles from './disc_styles.module.css';\n\ninterface Props {\n  collapsed: boolean;\n  itemId: string;\n  isCollapsible: boolean;\n}\n\n/*\n * 18. Tip - If i don't add `contentEditable={false}` in the Disc outer div,\n * clicking the mouse on the disc puts the cursor there, as if the whole disc\n * is content editable. I think draft-js, by default, makes all html elements\n * inside it as contenteditable. So if we don't want something as editable\n * entities, we have to specifiy it explicitly.\n *\n * 19. Question? - Is it better to use Entities for this? Define an entity which is\n * IMMUTABLE and then tell that Disc is that type of entity?\n */\nexport default function Disc({ collapsed, itemId, isCollapsible }: Props) {\n  const { onZoom, onExpandClick, onCollapseClick } = React.useContext(\n    EditorContext\n  );\n\n  return (\n    <div className={styles['disc-container']} style={{ marginTop: 2 }}>\n      {isCollapsible && (\n        <button\n          className={styles['collapse-button']}\n          style={{\n            marginTop: -2,\n          }}\n          onClick={() => {\n            if (collapsed) {\n              if (typeof onExpandClick === 'function') {\n                onExpandClick(itemId);\n              }\n            } else {\n              if (typeof onCollapseClick === 'function') {\n                onCollapseClick(itemId);\n              }\n            }\n          }}\n          data-testid=\"collapse-arrow\"\n        >\n          <DownArrow\n            className={classNames(styles['down-arrow-icon'], {\n              [styles['collapsed-down-arrow-icon']]: collapsed,\n            })}\n            width={8}\n            height={8}\n          />\n        </button>\n      )}\n      <div\n        contentEditable={false}\n        className={classNames(styles['disc'], {\n          [styles['disc-collapsed']]: collapsed,\n        })}\n        onClick={() => {\n          if (typeof onZoom === 'function') {\n            onZoom(itemId);\n          }\n        }}\n        data-testid=\"outer-disc\"\n      >\n        <svg\n          width=\"6\"\n          height=\"6\"\n          className={styles['disc-icon']}\n          viewBox=\"0 0 6 6\"\n        >\n          <circle cx=\"3\" cy=\"3\" r=\"3\" />\n        </svg>\n      </div>\n    </div>\n  );\n}\n","import * as React from 'react';\n\nexport default function PlusSign(props: React.SVGProps<SVGSVGElement>) {\n  return (\n    <svg\n      version=\"1.1\"\n      id=\"Capa_1\"\n      xmlns=\"http://www.w3.org/2000/svg\"\n      xmlnsXlink=\"http://www.w3.org/1999/xlink\"\n      x=\"0px\"\n      y=\"0px\"\n      viewBox=\"0 0 512 512\"\n      enableBackground=\"new 0 0 512 512\"\n      xmlSpace=\"preserve\"\n      {...props}\n    >\n      <g>\n        <g>\n          <path\n            d=\"M492,236H276V20c0-11.046-8.954-20-20-20c-11.046,0-20,8.954-20,20v216H20c-11.046,0-20,8.954-20,20s8.954,20,20,20h216\n\t\t\tv216c0,11.046,8.954,20,20,20s20-8.954,20-20V276h216c11.046,0,20-8.954,20-20C512,244.954,503.046,236,492,236z\"\n          />\n        </g>\n      </g>\n    </svg>\n  );\n}\n","import * as React from 'react';\n\nexport default function MinusSign(props: React.SVGProps<SVGSVGElement>) {\n  return (\n    <svg\n      version=\"1.1\"\n      id=\"Capa_1\"\n      xmlns=\"http://www.w3.org/2000/svg\"\n      xmlnsXlink=\"http://www.w3.org/1999/xlink\"\n      x=\"0px\"\n      y=\"0px\"\n      viewBox=\"0 0 512 512\"\n      enableBackground=\"new 0 0 512 512\"\n      xmlSpace=\"preserve\"\n      {...props}\n    >\n      <g>\n        <rect y={236} width={512} height={40} />\n      </g>\n    </svg>\n  );\n}\n","import * as React from 'react';\nimport classNames from 'classnames';\nimport { ContentBlock, EditorBlock } from 'draft-js';\nimport Disc from './Disc';\nimport PlusSign from '../../icons/PlusSign';\nimport MinusSign from '../../icons/MinusSign';\n\nimport styles from './item_styles.module.css';\n\ninterface Props {\n  block: ContentBlock;\n  blockProps: {\n    zoomedInItemId: string;\n    baseDepth: number;\n    searchText?: string;\n    hidden: boolean;\n    onExpandClick: (blockKey: string) => void;\n    onCollapseClick: (blockKey: string) => void;\n  };\n}\n\n/**\n * Hacky but works\n * We wrap the item in nested divs each with class depth-manager mainly to get\n * the vertical line which connects the various item bullet dot together.\n * If we simply adding a margin-left of (depth * someMargin) on the item div\n * itself, we would not be able to show that vertical line by simply adding\n * a left-border and. The left border trick works only by creating the left\n * space in each depth-manager using a padding. It won't work with a margin-left\n */\nfunction wrapInNestedDivs(\n  el: React.ReactElement,\n  props: any,\n  depth: number\n): React.ReactElement {\n  if (depth <= 0) {\n    return el;\n  }\n\n  return React.createElement(\n    'div',\n    props,\n    wrapInNestedDivs(el, props, depth - 1)\n  );\n}\n\nfunction areEqual(prevProps: Props, newProps: Props) {\n  const {\n    block: prevBlock,\n    blockProps: {\n      hidden: prevHidden,\n      baseDepth: prevBaseDepth,\n      searchText: prevSearchText,\n    },\n  } = prevProps;\n  const {\n    block: nextBlock,\n    blockProps: {\n      hidden: nextHidden,\n      baseDepth: nextBaseDepth,\n      searchText: nextSearchText,\n    },\n  } = newProps;\n\n  return (\n    prevBlock === nextBlock &&\n    prevHidden === nextHidden &&\n    prevBaseDepth === nextBaseDepth &&\n    prevSearchText === nextSearchText\n  );\n}\n\nexport const Item = React.memo((props: Props) => {\n  const { block, blockProps } = props;\n  const {\n    onExpandClick,\n    onCollapseClick,\n    hidden,\n    baseDepth,\n    zoomedInItemId,\n  } = blockProps;\n\n  const collapsed = block.getIn(['data', 'collapsed']);\n  const completed = block.getIn(['data', 'completed']);\n  const collapsible = block.getIn(['data', 'hasChildren']);\n\n  /*\n   * 7. When i try rendering the block on my own by wrapping the list item\n   * EditorBlock inside my own html, it puts the whole div inside the rendered\n   * li! So i 1. wrote css to hide the bullet for the li(s). 2. Render a small\n   * circle like bullet of my own before the EditorBlock renders the text.\n   *\n   * Now i can control the various looks of the bullet based on\n   * 1. Whether they are collapsed or not\n   * 2. Whether user has marked it complete or not\n   * 3. And i can add the arrow before the bullet to allow users to collapse or\n   * expand a list item\n   */\n\n  if (hidden) {\n    return null;\n  }\n\n  const depth = block.getDepth();\n  // most of the conditional classes are for the zoomed in item. It's special.\n  const itemClasses = classNames(styles['item-base'], {\n    [styles.completed]: completed,\n    [styles['regular-item']]: zoomedInItemId !== block.getKey(),\n    [styles['zoomed-in-item']]: zoomedInItemId === block.getKey(),\n    [styles['small-text']]:\n      zoomedInItemId !== block.getKey() && depth > baseDepth + 1,\n  });\n\n  return wrapInNestedDivs(\n    <div\n      className={itemClasses}\n      style={{\n        marginLeft: -13,\n        // can't use tailwind classes for this since it has to increase linearly\n        // and tailwind values don't increase linearly\n        // we have to use this marginLeft if we don't use wrapInNestedDivs\n        // marginLeft: `${Math.max(0, 2 * (depth - baseDepth - 1))}rem`,\n      }}\n      data-testid=\"list-item\"\n    >\n      {block.getDepth() > baseDepth && (\n        <Disc\n          itemId={block.getKey()}\n          collapsed={!!collapsed}\n          isCollapsible={collapsible}\n        />\n      )}\n      {/* I had to add display: 'block' to get the edit cursor to work on empty list item. \n\t\tOtherwise, the edit cursor was not visible on empty item. It would come after typing one \n\t\tcharater */}\n      <div className={styles['item-container']}>\n        <EditorBlock {...props} />\n        {collapsible ? (\n          !collapsed ? (\n            <button\n              contentEditable={false}\n              className={styles['mobile-collapse-button']}\n              onMouseDown={e => {\n                e.stopPropagation();\n                e.nativeEvent.stopImmediatePropagation();\n                onCollapseClick(block.getKey());\n              }}\n              data-testid=\"collapse-button\"\n            >\n              <MinusSign width={16} height={16} />\n            </button>\n          ) : (\n            <button\n              contentEditable={false}\n              className={styles['mobile-collapse-button']}\n              onMouseDown={e => {\n                e.stopPropagation();\n                e.nativeEvent.stopImmediatePropagation();\n                onExpandClick(block.getKey());\n              }}\n              data-testid=\"expand-button\"\n            >\n              <PlusSign width={16} height={16} />\n            </button>\n          )\n        ) : null}\n      </div>\n    </div>,\n    {\n      className: classNames('depth-manager', styles['depth-manager']),\n    },\n    depth - baseDepth - 1\n  );\n}, areEqual);\n\nItem.displayName = 'Item';\n","import {\n  EditorState,\n  ContentState,\n  ContentBlock,\n  SelectionState,\n} from 'draft-js';\n\nimport pluckGoodies from './pluck_goodies';\nimport { getPosNum, getPosAfter, getPosInBetween } from './pos_generators';\nimport { recreateParentBlockMap } from './recreate_parent_block_map';\nimport { calculateDepth } from './calculate_depth';\nimport {\n  getChildren,\n  getFirstChild,\n  getNextSibling,\n  getPreviousSibling,\n} from './tree_utils';\nimport { getBlocksWithItsDescendants } from './tree_utils';\n\nfunction moveBlock(\n  contentState: ContentState,\n  blockToSwapWith: ContentBlock,\n  blockToMoveKey: string,\n  newParentId: string,\n  newPos: number\n) {\n  const blockMap = contentState.getBlockMap();\n  let anchorBlock = blockMap.get(blockToMoveKey);\n  const parentId = anchorBlock.getIn(['data', 'parentId']);\n  anchorBlock = anchorBlock\n    .setIn(['data', 'parentId'], newParentId)\n    .setIn(['data', 'pos'], newPos) as ContentBlock;\n\n  let newBlockMap = blockMap\n    .set(blockToMoveKey, anchorBlock)\n    .set(blockToSwapWith.getKey(), blockToSwapWith);\n\n  // the order of operation for redoing the recreateParentBlockMap for\n  // parentId and newParentId is very important.\n  // because OrderedMap is also a map at the end of the day,\n  // so .concat works weirdly if we try to concatenate something which is\n  // already present in the map\n  // If we are moving something to new parent, wouldn't a single call to\n  // recreateParentBlockMap solve all our problems? i.e. wouldn't it\n  // automatically remove the block from it's previous position? No. Because the\n  // block will be with it's old parent in the map and when trying to\n  // concatenate a small part of the tree in a different node, the OrderedMap\n  // would probably keep only one version of the altered block. Probably the\n  // one which comes earlier. I don't know.\n  // If we are doing a move, updating the current parent tree should essentially\n  // delete the block from the whole blockMap\n  newBlockMap = recreateParentBlockMap(\n    contentState.set('blockMap', newBlockMap) as ContentState,\n    newBlockMap,\n    parentId\n  );\n  // all we have to do is again reattach the anchorBlock to newBlockMap before\n  // recreating the newParentId tree\n  if (newParentId !== parentId) {\n    newBlockMap = newBlockMap.merge(\n      getBlocksWithItsDescendants(blockMap, blockToMoveKey)\n    );\n    newBlockMap = newBlockMap.set(blockToMoveKey, anchorBlock);\n    newBlockMap = recreateParentBlockMap(\n      contentState.set('blockMap', newBlockMap) as ContentState,\n      newBlockMap,\n      newParentId\n    );\n  }\n\n  return newBlockMap;\n}\n\nfunction getBlockToInsertBefore(editorState: EditorState) {\n  const { blockMap, anchorKey } = pluckGoodies(editorState);\n  const block = blockMap.get(anchorKey);\n\n  const previousSibling = getPreviousSibling(blockMap, anchorKey);\n\n  // two cases\n  // 1. Either move the item before it's previous sibling\n  // 2. If there is no previous sibling, move it as the last child of the previous sibling of it's parent\n\n  if (previousSibling) {\n    return previousSibling;\n  }\n\n  const parent = blockMap.get(block.getIn(['data', 'parentId']));\n  const parentsPreviousSibling = getPreviousSibling(blockMap, parent.getKey());\n\n  if (!parentsPreviousSibling) {\n    return null;\n  }\n\n  const children = getChildren(blockMap, parentsPreviousSibling.getKey());\n\n  if (children.count() > 0) {\n    return children.last();\n  } else {\n    return parentsPreviousSibling;\n  }\n}\n\n// which block should we insert the current block after when moving down?\n// Can't just take the next one and say insert after that. Don't want to do\n// that if it's the child of the block to be moved\nfunction getBlockToInsertAfter(editorState: EditorState) {\n  const { blockMap, anchorKey } = pluckGoodies(editorState);\n  const block = blockMap.get(anchorKey);\n\n  const nextSibling = getNextSibling(blockMap, anchorKey);\n\n  // two cases\n  // 1. Either move the item after it's next sibling\n  // 2. If there is no next sibling, it's the last child. Move it as the first child of the next sibling of the parent\n  if (nextSibling) {\n    return nextSibling;\n  }\n\n  const parent = blockMap.get(block.getIn(['data', 'parentId']));\n  const parentNextSibling = getNextSibling(blockMap, parent.getKey());\n\n  if (!parentNextSibling) {\n    return null;\n  }\n\n  return parentNextSibling;\n}\n\nexport function moveCurrentBlockUp(\n  editorState: EditorState,\n  zoomedInItemId?: string\n) {\n  const { contentState, blockMap, selectionState, anchorKey } = pluckGoodies(\n    editorState\n  );\n\n  let blockToSwapWith = getBlockToInsertBefore(editorState);\n\n  if (!blockToSwapWith) {\n    console.log('moveCurrentBlockUp', 'nothing to swap with');\n    return editorState;\n  }\n\n  // we are trying to move a block above the currently zoomed in item, do\n  // nothing\n  if (\n    zoomedInItemId &&\n    (blockToSwapWith.getKey() === zoomedInItemId ||\n      (contentState.getBlockAfter(blockToSwapWith.getKey()) &&\n        contentState.getBlockAfter(blockToSwapWith.getKey()).getKey() ===\n          zoomedInItemId))\n  ) {\n    return editorState;\n  }\n  /*\n   * This will not work when we move multiple blocks or move blocks across\n   * depths. E.g. if i move a child item in depth 1 up, it should not replace\n   * it's parent but move beyond that and as a child of the earlier higher level\n   * item. Such things are much better done with a 'delete and insert' operation\n   *\n   * 1. Determine the key of block to be remove - anchorKey\n   * 2. Determine the index where it needs to be inserted\n   * 3. Delete the block from map using key\n   * 4. Convert blockMap to seq and insert the deleted block at (index - 1).\n   * Maybe using concat like we are doing below or some better way.\n   * If nothing else, let's fallback to our trusted `reduce` :)\n   *\n   * Will need a separate algorithm when we need to move multiple blocks\n   * because the block to be moved is collapsed.\n   *\n   */\n\n  const anchorBlock = blockMap.get(anchorKey);\n\n  // Instead of doing so many shenanigans, all we need to determine\n  // is the blocks new parentId and pos. There might be 2 cases with parentId\n  // 1. It remains the same\n  // 2. It changes\n  // In case 1. we call recreateParentBlockMap after changing the pos for\n  // affected blocks (swapped ones)\n  // In case 2. we change parentId of moved block and it's pos and then\n  // call recreateParentBlockMap for both the new and the old parentIds\n  const parentId = anchorBlock.getIn(['data', 'parentId']);\n  let newParentId;\n  let newPos;\n\n  if (blockToSwapWith.getIn(['data', 'parentId']) === parentId) {\n    newParentId = parentId;\n    newPos = blockToSwapWith.getIn(['data', 'pos']);\n    blockToSwapWith = blockToSwapWith.setIn(\n      ['data', 'pos'],\n      anchorBlock.getIn(['data', 'pos'])\n    ) as ContentBlock;\n  } else {\n    // we are moving below the child the preceding parent block\n    if (\n      calculateDepth(blockMap, blockToSwapWith.getKey()) ===\n      calculateDepth(blockMap, anchorBlock.getKey())\n    ) {\n      newParentId = blockToSwapWith.getIn(['data', 'parentId']);\n      newPos = getPosAfter(blockToSwapWith.getIn(['data', 'pos']));\n    } else {\n      // we are probably moving inside an item without any children\n      newParentId = blockToSwapWith.getKey();\n      newPos = getPosNum(1);\n    }\n  }\n\n  const newBlockMap = moveBlock(\n    contentState,\n    blockToSwapWith,\n    anchorKey,\n    newParentId,\n    newPos\n  );\n\n  const newContentState = contentState.merge({\n    blockMap: newBlockMap,\n  }) as ContentState;\n\n  const newSelection = new SelectionState({\n    anchorKey: anchorKey,\n    anchorOffset: selectionState.getAnchorOffset(),\n    focusKey: anchorKey,\n    focusOffset: selectionState.getFocusOffset(),\n  });\n\n  // Always, always use this method to modify editorState when in doubt about\n  // how to edit the editor state. It maintains the undo/redo stack for the\n  // stack - https://draftjs.org/docs/api-reference-editor-state#push\n  const newState = EditorState.push(\n    editorState,\n    newContentState,\n    'move-block' as any\n  );\n\n  return EditorState.forceSelection(newState, newSelection);\n}\n\nexport function moveCurrentBlockDown(\n  editorState: EditorState,\n  zoomedInItemId?: string\n) {\n  const { contentState, selectionState, blockMap, anchorKey } = pluckGoodies(\n    editorState\n  );\n\n  // TODO: write function to find the block to swap with when dealing with\n  // nested items\n  let blockToSwapWith = getBlockToInsertAfter(editorState);\n\n  if (!blockToSwapWith || blockToSwapWith.getKey() === anchorKey) {\n    console.log('moveCurrentBlockDown', 'nothing to swap with');\n    return editorState;\n  }\n\n  const anchorBlock = blockMap.get(anchorKey);\n\n  // Instead of doing so many shenanigans, all we need to determine\n  // is the blocks new parentId and pos. There might be 2 cases with parentId\n  // 1. It remains the same\n  // 2. It changes\n  // In case 1. we call recreateParentBlockMap after changing the pos for\n  // affected blocks (swapped ones)\n  // In case 2. we change parentId of moved block and it's pos and then\n  // call recreateParentBlockMap for both the new and the old parentIds\n  const parentId = anchorBlock.getIn(['data', 'parentId']);\n  let newParentId;\n  let newPos;\n\n  // We found a sibling to swap positions with\n  if (blockToSwapWith.getIn(['data', 'parentId']) === parentId) {\n    newParentId = parentId;\n    newPos = blockToSwapWith.getIn(['data', 'pos']);\n    blockToSwapWith = blockToSwapWith.setIn(\n      ['data', 'pos'],\n      anchorBlock.getIn(['data', 'pos'])\n    ) as ContentBlock;\n  } else {\n    // we might be trying to push the item to the zoomed in items next sibling\n    // which will make the block disappear from the zoomed in editor state\n    // let's not allow that\n    if (zoomedInItemId === anchorBlock.getIn(['data', 'parentId'])) {\n      return editorState;\n    }\n\n    // the blockToSwapWith has to be it's parent, if eligible\n    newParentId = blockToSwapWith.getKey();\n    const firstChild = getFirstChild(blockMap, blockToSwapWith.getKey());\n    // const newParentsChildren = getChildren(blockMap, blockToSwapWith.getKey());\n\n    // we are moving above the first child of the next parent block\n    // case 1 - If there are already some parents present\n    if (firstChild) {\n      newPos = getPosInBetween(0, firstChild.getIn(['data', 'pos']));\n    } else {\n      // case 2 - There are not existing children. This item will be the first child.\n      newPos = getPosNum(1);\n    }\n  }\n\n  const newBlockMap = moveBlock(\n    contentState,\n    blockToSwapWith,\n    anchorKey,\n    newParentId,\n    newPos\n  );\n\n  const newContentState = contentState.merge({\n    blockMap: newBlockMap,\n  }) as ContentState;\n  const newSelection = new SelectionState({\n    anchorKey: anchorKey,\n    anchorOffset: selectionState.getAnchorOffset(),\n    focusKey: anchorKey,\n    focusOffset: selectionState.getFocusOffset(),\n  });\n\n  // Always, always use this method to modify editorState when in doubt about\n  // how to edit the editor state. It maintains the undo/redo stack for the\n  // stack - https://draftjs.org/docs/api-reference-editor-state#push\n  const newState = EditorState.push(\n    editorState,\n    newContentState,\n    'move-block' as any\n  );\n\n  return EditorState.forceSelection(newState, newSelection);\n}\n","import {\n  ContentState,\n  ContentBlock,\n  EditorState,\n  SelectionState,\n} from 'draft-js';\n\nimport pluckGoodies from './pluck_goodies';\nimport { getBlocksWithItsDescendants } from './tree_utils';\n\nfunction toggleCollapseState(\n  editorState: EditorState,\n  collapseState: boolean,\n  blockKey: string\n) {\n  const { contentState, selectionState, blockMap } = pluckGoodies(editorState);\n  const block = blockMap.get(blockKey);\n\n  // if the block does not exists\n  // or if the collapsed state is already in the desired state, let it be\n  if (!block || block.getIn(['data', 'collapsed']) === collapseState) {\n    return editorState;\n  }\n\n  const blockWithItsChildren = getBlocksWithItsDescendants(blockMap, blockKey);\n  // if this list contains just one item, it's that block itself. There are\n  // no children to collapse\n  if (!blockWithItsChildren || blockWithItsChildren.count() === 1) {\n    return editorState;\n  }\n\n  const newContentState = contentState.merge({\n    blockMap: blockMap.set(\n      blockKey,\n      block.setIn(['data', 'collapsed'], collapseState) as ContentBlock\n    ),\n  }) as ContentState;\n\n  const newSelection = new SelectionState({\n    anchorKey: blockKey,\n    anchorOffset: selectionState.getAnchorOffset(),\n    // There is a bug where when i click expand/collapse arrow of any item, the\n    // draft-js code throws an exception. It seems to happen consistently when\n    // i click the first item arrow with mouse. Happens randomly for other\n    // items on and off.\n    // And looks like it doesn't happen again if i set the focusKey to\n    // undefined. Definitely not an ideal bug fix.\n    // TODO: figure out why this might happen. What is the focusKey exactly\n    // doing?\n    focusKey: undefined,\n    focusOffset: selectionState.getFocusOffset(),\n  });\n  const newState = EditorState.push(\n    editorState,\n    newContentState,\n    collapseState ? 'collapse-list' : ('expand-list' as any)\n  );\n\n  return EditorState.forceSelection(newState, newSelection);\n}\n\nexport function collapseBlock(\n  editorState: EditorState,\n  blockKey: string\n): EditorState {\n  const { anchorKey } = pluckGoodies(editorState);\n\n  return toggleCollapseState(editorState, true, blockKey || anchorKey);\n}\n\nexport function expandBlock(\n  editorState: EditorState,\n  blockKey: string\n): EditorState {\n  const { anchorKey } = pluckGoodies(editorState);\n\n  return toggleCollapseState(editorState, false, blockKey || anchorKey);\n}\n\n/*\n * bug - if the cursor is at end of line of the list item, expand does\n * not work. If the cursor is anywhere else on the line, it works\n * Root cause - selectionState.getAnchorKey, getStartKey, getFocusKey - all\n * return the wrong information when the cursor is at the end of line. They\n * return the last child of the collapsed item as the anchor block\n * Once we collapse the item, the selection state goes wrong. It sets itself\n * to the last child of the collapsed item. Probably because draftjs also\n * handles command+up or command+down? don't know.\n *\n * bug - Once expanded, creating new item with 'Enter' key creates the\n * new item as a child of the current item. Because the selectionState is\n * pointing to the last child of this item. Just hiding the block with\n * display: none is not a viable solution. Also because we are not controlling\n * the wrapper li for each list item. That's controlled by draft-js. We\n * are just hiding the content inside that li. We might need to completely\n * remove those blocks from contentState when collapsing items. And maintain\n * a master contentState somewhere. But that would create problems of\n * syncing that master contentState with changed contentState while editing\n * a current one which has one or more collapsed items. Hmm...\n */\n","import {\n  SelectionState,\n  ContentState,\n  EditorState,\n  BlockMap,\n  ContentBlock,\n} from 'draft-js';\n\nimport { ROOT_KEY } from '../constants';\n\nimport { getPosNum, getPosAfter, getPosInBetween } from './pos_generators';\nimport { recreateParentBlockMap } from './recreate_parent_block_map';\nimport { calculateDepth } from './calculate_depth';\nimport { adjustHasChildren } from './tree_utils';\n\nfunction getParentIdAfterAdjustment(\n  contentState: ContentState,\n  indentBlockKey: string,\n  newDepth: number\n): string {\n  let previousBlock = contentState.getBlockBefore(indentBlockKey);\n  const blockMap = contentState.getBlockMap();\n\n  // TODO: Add description about what we are doing in this while loop\n  while (previousBlock) {\n    if (calculateDepth(blockMap, previousBlock.getKey()) < newDepth) {\n      return previousBlock.getKey();\n    }\n\n    previousBlock = contentState.getBlockBefore(previousBlock.getKey());\n  }\n\n  return ROOT_KEY;\n}\n\n/**\n * Once we find the parentId after indent or dedent, we don't need the exact\n * operation which was performed. We can use the parentId to get all the current\n * nodes with same parentId, the adjusted blocks position in those children\n * and hence the adjusted blocks new postion\n */\nfunction getPosAfterAdjustment(\n  blockMap: BlockMap,\n  adjustedBlockKey: string,\n  newParentId: string\n): number {\n  // we get the blockMap with adjusted parentId. This will help us get the\n  // position of the adjusted block in the children list\n  const blocksWithSameParent = blockMap\n    .filter(b => !!(b && b.get('data').get('parentId') === newParentId))\n    .toArray();\n\n  let i = 0;\n  let blockBefore;\n  let blockAfter;\n\n  while (i < blocksWithSameParent.length) {\n    // once we find the adjustment block, we know the surrounding 2 are\n    // actually it's blockBefore and blockAfter at the same depth\n    if (blocksWithSameParent[i].getKey() === adjustedBlockKey) {\n      blockBefore = blocksWithSameParent[i - 1];\n      blockAfter = blocksWithSameParent[i + 1];\n      break;\n    }\n\n    i += 1;\n  }\n\n  if (blockBefore && blockAfter) {\n    return getPosInBetween(\n      blockBefore.get('data').get('pos'),\n      blockAfter.get('data').get('pos')\n    );\n  } else if (blockBefore) {\n    return getPosAfter(blockBefore.get('data').get('pos'));\n  } else if (blockAfter) {\n    return getPosNum(1);\n  } else {\n    return getPosNum(1);\n  }\n}\n\n// adjust block depth by +1 or -1 for the current item as well as all it's\n// children and the children of children recursively. We don't need to do it\n// recursively in this case because draftjs blockMap is ordered and we know\n// that we have handled all the descendents of the current item when we reach\n// another item which is at same depth as current item\nfunction adjustBlockDepthForContentState(\n  contentState: ContentState,\n  selectionState: SelectionState,\n  adjustment: number\n): ContentState {\n  // TODO: can we not use getBlocksWithItsChildren here? Probably not since we\n  // need any grandchildren and their children and theirs\n  const indentBlockKey = selectionState.getAnchorKey();\n\n  let blockMap = contentState.getBlockMap();\n  let indentBlock = blockMap.get(indentBlockKey);\n  const newDepth = calculateDepth(blockMap, indentBlockKey) + adjustment;\n  const oldParentId = indentBlock.getIn(['data', 'parentId']);\n\n  // TODO: When we dedent an item which is in between it's other siblings,\n  // we need to create the list of items from this dedented item's parent and\n  // downwards again and completely replace that list in the current blockMap.\n  // It will lead to things like an a middle sibling being dedented changing it's\n  // position in the list after the end of it's siblings but one level up.\n  // Check workflowy behavior.\n  // The only way to do it seems to be rearranging everything inside the parent\n  // of this dedented item.\n  // we can use arrToObj and loadFromDb functions to rearrange the affected\n  // blocks. Using getStartAndEndKeys we can get the blocks array from our\n  // blockMap and then use arrToObj to create an object map of the blocks and\n  // pass it to loadFromDb to get a block array again.\n  // To update the blocks inside BlockMap, which is an OrderedMap, we have to\n  // use the same trick that we use in splitBlock. Create a aboveBlocks,\n  // betweenBlocks and afterBlocks arrays and merge them to make the final\n  // blockMap again.\n  // something like\n  // blockMap.slice(0, indentBlockKey)\n  //    .concat(Immutable.OrderedMap(\n  //       // from [{ key: 'a' }, { key: 'b' } ] to\n  //       // [ ['a', { key: 'a' }], ['b', { key: 'b' }]]\n  //       // so that Immutable.OrderedMap can consume it correctly\n  //       convertToKeyValuePairs(\n  //         loadFromDb(new DB(blockMap.slice(indentBlockKey, endKey).toJS()))\n  //       )\n  //     )\n  //    .concat(blockMap.slice(endKey))\n  // Let's call that function recreateParentBlockMap()\n  const parentId = getParentIdAfterAdjustment(\n    contentState,\n    indentBlockKey,\n    newDepth\n  );\n\n  indentBlock = indentBlock.setIn(\n    ['data', 'parentId'],\n    parentId\n  ) as ContentBlock;\n  // we need to update blockMap before we send it to getPosAfterAdjustment\n  blockMap = blockMap.set(indentBlock.getKey(), indentBlock);\n  indentBlock = indentBlock.setIn(\n    ['data', 'pos'],\n    getPosAfterAdjustment(blockMap, indentBlock.getKey(), parentId)\n  ) as ContentBlock;\n\n  // set new parent id\n  blockMap = blockMap.set(indentBlockKey, indentBlock);\n  blockMap = recreateParentBlockMap(\n    contentState.set('blockMap', blockMap) as ContentState,\n    blockMap,\n    parentId\n  ) as BlockMap;\n\n  // if the parent block is collapsed, expand it\n  // otherwise we won't be able to see where the indented block went\n  if (adjustment === 1) {\n    const parentBlock = blockMap.get(parentId);\n    if (parentBlock.getIn(['data', 'collapsed'])) {\n      blockMap = blockMap.set(\n        parentId,\n        parentBlock.setIn(['data', 'collapsed'], false) as ContentBlock\n      ) as BlockMap;\n    }\n  }\n\n  // We want to adjust the hasChildren property of both the old parent block as well\n  // as the new parent block for the indented/dedented block\n  blockMap = adjustHasChildren(\n    adjustHasChildren(blockMap, oldParentId),\n    parentId\n  );\n\n  return contentState.merge({\n    blockMap,\n    selectionBefore: selectionState,\n    selectionAfter: selectionState,\n  }) as ContentState;\n}\n\n/*\n * Overriding the draft-js provided onTab function since it doesn't work on\n * multiple list items, i.e. an hierarchy of items. If i press tab on an item\n * which has children, it should move into the previous sibling along with all\n * it's children.\n * TODO: update parentKeys as appropriate\n */\nexport function onTab(\n  editorState: EditorState,\n  maxDepth: number,\n  zoomedInItemId?: string,\n  shiftKey = false\n) {\n  const selection = editorState.getSelection();\n  // TODO: Why are we using startBlockKey here? Why not anchorKey\n  const startBlockKey = selection.getStartKey();\n  const content = editorState.getCurrentContent();\n  const blockMap = content.getBlockMap();\n  const startBlock = content.getBlockForKey(startBlockKey);\n  const previousBlock = content.getBlockBefore(startBlockKey);\n  const baseDepth = zoomedInItemId\n    ? calculateDepth(blockMap, zoomedInItemId) + 1\n    : 0;\n\n  if (\n    // if the first block in selection is the first block overall, don't do\n    // anything. Either for tab or for shift-tab\n    !previousBlock ||\n    // if we are trying to change depth of the zoomed in item itself\n    calculateDepth(blockMap, startBlock.getKey()) < baseDepth ||\n    // if we are trying to dedent the direct children of the zoomed in item\n    (shiftKey && calculateDepth(blockMap, startBlock.getKey()) === baseDepth)\n  ) {\n    console.log('This seems like the first list item. Nothing to do.');\n    return editorState;\n  }\n\n  const depth = calculateDepth(blockMap, startBlock.getKey());\n\n  if (depth >= maxDepth) {\n    return editorState;\n  }\n\n  // we don't want a difference of more than one level between an item and\n  // it's previous block\n  if (\n    !shiftKey &&\n    calculateDepth(blockMap, startBlock.getKey()) -\n      calculateDepth(blockMap, previousBlock.getKey()) >=\n      1\n  ) {\n    return editorState;\n  }\n\n  const withAdjustment = adjustBlockDepthForContentState(\n    content,\n    selection,\n    shiftKey ? -1 : 1\n  );\n\n  // Always, always use this method to modify editorState when in doubt about\n  // how to edit the editor state. It maintains the undo/redo stack for the\n  // stack - https://draftjs.org/docs/api-reference-editor-state#push\n  return EditorState.push(editorState, withAdjustment, 'adjust-depth');\n}\n","import {\n  EditorState,\n  RichUtils,\n  SelectionState,\n  ContentState,\n  BlockMap,\n  ContentBlock,\n} from 'draft-js';\n\nimport pluckGoodies from './pluck_goodies';\n\nimport {\n  getBlocksWithItsDescendants,\n  hasChildren,\n  adjustHasChildren,\n} from './tree_utils';\nimport { moveCurrentBlockUp, moveCurrentBlockDown } from './move';\nimport { collapseBlock, expandBlock } from './collapse_expand_block';\n// import { makeCorrectionsToNodeAndItsDescendants } from './make_corrections_to_node_and_its_descendants';\nimport { ROOT_KEY, MAX_DEPTH } from '../constants';\nimport { onTab } from './tab';\n\nexport const CHANGE = 'CHANGE';\nexport const SET_ROOT_EDITOR_STATE = 'SET_ROOT_EDITOR_STATE';\nexport const SET_EDITOR_STATE = 'SET_EDITOR_STATE';\nexport const SET_STATE = 'SET_STATE';\nexport const INSERT_SOFT_NEWLINE = 'INSERT_SOFT_NEWLINE';\nexport const ZOOM = 'ZOOM';\nexport const COLLAPSE_ITEM = 'COLLAPSE_ITEM';\nexport const EXPAND_ITEM = 'EXPAND_ITEM';\nexport const EXPAND_ALL = 'EXPAND_ALL';\nexport const COLLAPSE_ALL = 'COLLAPSE_ALL';\nexport const MOVE_UP = 'MOVE_UP';\nexport const MOVE_DOWN = 'MOVE_DOWN';\nexport const TOGGLE_COMPLETION = 'TOGGLE_COMPLETION';\nexport const DELETE_CURRENT_ITEM = 'DELETE_CURRENT_ITEM ';\nexport const INDENT = 'INDENT';\nexport const DEDENT = 'DEDENT';\nexport const BOOKMARK = 'BOOKMARK';\n\nexport interface DeepnotesEditorState {\n  // This is for future, when editorState will only have blocks which are under the zoomed in item node. The rootEditorState will always have all the blocks.\n  rootEditorState: EditorState;\n  editorState: EditorState;\n  zoomedInItemId: string;\n}\n\ninterface ChangeAction {\n  type: typeof CHANGE;\n  editorState: EditorState;\n}\n\ninterface InsertSoftNewlineAction {\n  type: typeof INSERT_SOFT_NEWLINE;\n}\n\ninterface SetRootEditorStateAction {\n  type: typeof SET_ROOT_EDITOR_STATE;\n  editorState: EditorState;\n}\n\ninterface SetEditorStateAction {\n  type: typeof SET_EDITOR_STATE;\n  editorState: EditorState;\n}\n\ninterface SetStateAction {\n  type: typeof SET_STATE;\n  prop: string;\n  val: any;\n}\n\ninterface MoveUpAction {\n  type: typeof MOVE_UP;\n}\n\ninterface MoveDownAction {\n  type: typeof MOVE_DOWN;\n}\n\ninterface CollapseItemAction {\n  type: typeof COLLAPSE_ITEM;\n  blockKey: string;\n}\n\ninterface ExpandItemAction {\n  type: typeof EXPAND_ITEM;\n  blockKey: string;\n}\n\ninterface ExpandAllAction {\n  type: typeof EXPAND_ALL;\n}\n\ninterface CollapseAllAction {\n  type: typeof COLLAPSE_ALL;\n}\n\ninterface ZoomAction {\n  type: typeof ZOOM;\n  blockKey: string;\n}\ninterface ToggleCompletionAction {\n  type: typeof TOGGLE_COMPLETION;\n}\n\ninterface DeleteCurrentItemAction {\n  type: typeof DELETE_CURRENT_ITEM;\n}\n\ninterface IndentItemAction {\n  type: typeof INDENT;\n}\n\ninterface DedentItemAction {\n  type: typeof DEDENT;\n}\n\ninterface BookmarkAction {\n  type: typeof BOOKMARK;\n}\n\nexport type EditorActions =\n  | BookmarkAction\n  | IndentItemAction\n  | DedentItemAction\n  | ExpandAllAction\n  | CollapseAllAction\n  | DeleteCurrentItemAction\n  | ToggleCompletionAction\n  | ZoomAction\n  | SetStateAction\n  | ChangeAction\n  | InsertSoftNewlineAction\n  | SetRootEditorStateAction\n  | SetEditorStateAction\n  | MoveUpAction\n  | MoveDownAction\n  | CollapseItemAction\n  | ExpandItemAction;\n\nfunction updateSelectionForZoom(\n  editorState: EditorState,\n  zoomedInItemId: string\n) {\n  const { selectionState, blockMap } = pluckGoodies(editorState);\n  let newSelectionState = selectionState;\n\n  const blockWithItsChildren = getBlocksWithItsDescendants(\n    blockMap,\n    zoomedInItemId\n  );\n  // if the zoomed in item has children, let's focus the first child\n  if (blockWithItsChildren.count() > 1) {\n    // check if one of the children has focus\n    const childWithFocus = blockWithItsChildren.find(\n      block => !!(block && block.getKey() === selectionState.getAnchorKey())\n    );\n\n    // if one of the children has focus, just maintain that focus\n    // else, focus the first child\n    if (!childWithFocus) {\n      const firstChild = blockWithItsChildren.rest().first();\n      newSelectionState = SelectionState.createEmpty(firstChild.getKey());\n    }\n  } else {\n    // if the zoomed in item also has the focus, we should retain it's cursor\n    // position. Else create new focus on the zoomedin item with cursor at\n    // start of line.\n    if (selectionState.getAnchorKey() !== zoomedInItemId) {\n      newSelectionState = SelectionState.createEmpty(zoomedInItemId);\n    }\n  }\n\n  return EditorState.forceSelection(editorState, newSelectionState);\n}\n\n// This function create a new editorState with blocks only in the sub tree rooted at the zoomedInItemId\n// function withBlocksForZoomedInItem(\n// editorState: EditorState,\n// zoomedInItemId: string,\n// ) {\n// const { blockMap } = pluckGoodies(editorState);\n\n// const blocks = makeCorrectionsToNodeAndItsDescendants(\n// blockMap,\n// blockMap.get(zoomedInItemId),\n// );\n\n// return EditorState.createWithContent(\n// ContentState.createFromBlockArray(blocks),\n// );\n// }\n\nfunction zoomReducer(state: DeepnotesEditorState, itemId: string) {\n  const { editorState, zoomedInItemId } = state;\n  const { blockMap } = pluckGoodies(editorState);\n\n  // if there no zoomed in item, that means there's nothing to zoom out into\n  // If the zoomed in fellow is same is item to zoom into, the zoom reducer\n  // is probably called because the search text changed\n  // can't be because now we removed searchText from query string\n  if (zoomedInItemId === itemId) {\n    console.log('We are at the root. Nothing to zoom out into.');\n    return state;\n  }\n\n  let zoomedBlock;\n\n  // if we are provided itemId to zoom out to\n  if (itemId) {\n    zoomedBlock = blockMap.get(itemId);\n  }\n\n  const newZoomedInItemId = zoomedBlock ? zoomedBlock.getKey() : ROOT_KEY;\n\n  // if the zoom is done to the root level, there will be no particular block\n  // to zoom into. And zoomedBlock would be empty in that case. And we\n  // don't need to maintain a separate wholeEditorState\n  return {\n    ...state,\n    // we forceupdate the editor state to itself so that the editor refreshes\n    // If we don't do that, we set the new zoomedInItemId but the editor does\n    // not render again with that information\n    // TODO: Instead of forceupdate, we can update the selection on editorState\n    // We anyways should do it on zoomins. Updating selection, even if it leads\n    // to same selection state, would automatically get draftjs to rerender.\n    editorState: updateSelectionForZoom(state.editorState, newZoomedInItemId),\n    zoomedInItemId: newZoomedInItemId,\n  };\n}\n\nfunction toggleCompleteReducer(state: DeepnotesEditorState) {\n  const { blockMap, anchorBlock, contentState, selectionState } = pluckGoodies(\n    state.editorState\n  );\n\n  // Don't do anything if the item is empty\n  if (anchorBlock.getText().trim() === '') {\n    return state;\n  }\n\n  const blocksWithItsDescendants = getBlocksWithItsDescendants(\n    blockMap,\n    anchorBlock.getKey()\n  );\n\n  const newBlockMap = blockMap.merge(\n    blocksWithItsDescendants.map(b =>\n      b\n        ? b.setIn(\n            ['data', 'completed'],\n            !anchorBlock.getIn(['data', 'completed'])\n          )\n        : b\n    ) as BlockMap\n  );\n\n  const newContentState = contentState.merge({\n    blockMap: newBlockMap,\n    selectionBefore: selectionState,\n    selectionAfter: selectionState,\n  }) as ContentState;\n\n  return {\n    ...state,\n    editorState: EditorState.push(\n      state.editorState,\n      newContentState,\n      'toggle-completion' as any\n    ),\n  };\n}\n\nfunction deleteItemWithChildren(state: DeepnotesEditorState) {\n  const { editorState } = state;\n  const { contentState, blockMap, focusKey, focusBlock } = pluckGoodies(\n    editorState\n  );\n\n  if (!focusKey) {\n    return state;\n  }\n\n  const blocksToDelete = getBlocksWithItsDescendants(blockMap, focusKey);\n  const parentId = blockMap.get(focusKey).getIn(['data', 'parentId']);\n\n  let newBlockMap = blockMap\n    .toSeq()\n    .filter((_: any, k?: string) => !!(k && !blocksToDelete.has(k)))\n    .toOrderedMap();\n\n  // don't allow deleting if there is only one item in the list\n  if (\n    !newBlockMap ||\n    newBlockMap.count() === 0 ||\n    // at root level, the block map will still have one item, the root item\n    (newBlockMap.count() === 1 && newBlockMap.has(ROOT_KEY))\n  ) {\n    return state;\n  }\n\n  const pSibling = contentState.getBlockBefore(focusBlock.getKey());\n\n  let newSelection;\n\n  if (pSibling) {\n    newSelection = new SelectionState({\n      anchorKey: pSibling.getKey(),\n      anchorOffset: pSibling.getText().length - 1,\n      focusKey: pSibling.getKey(),\n      focusOffset: pSibling.getText().length - 1,\n    });\n  } else {\n    // what if it's the only item in the list?\n    newSelection = SelectionState.createEmpty(\n      newBlockMap\n        .toSeq()\n        .first()\n        .getKey()\n    );\n  }\n\n  // reset the hasChildren state of the parent block\n  newBlockMap = adjustHasChildren(newBlockMap, parentId);\n\n  return {\n    ...state,\n    editorState: EditorState.push(\n      editorState,\n      contentState.merge({\n        blockMap: newBlockMap,\n        selectionBefore: newSelection,\n        selectionAfter: newSelection,\n      }) as ContentState,\n      'delete-item' as any\n    ),\n  };\n}\n\nfunction expandCollapseAll(state: DeepnotesEditorState, collapse: boolean) {\n  const { editorState, zoomedInItemId } = state;\n  const { blockMap, contentState } = pluckGoodies(editorState);\n\n  let blocksWithItsDescendants = getBlocksWithItsDescendants(\n    blockMap,\n    zoomedInItemId\n  );\n\n  blocksWithItsDescendants = blocksWithItsDescendants.rest().map(b => {\n    if (!b) {\n      return b;\n    } else {\n      if (hasChildren(blockMap, b.getKey())) {\n        return b.setIn(['data', 'collapsed'], collapse);\n      } else {\n        return b;\n      }\n    }\n  }) as BlockMap;\n  const newBlockMap = blockMap.merge(blocksWithItsDescendants);\n\n  const newEditorState = EditorState.push(\n    editorState,\n    contentState.set('blockMap', newBlockMap) as ContentState,\n    'collapse-all' as any\n  );\n\n  return {\n    ...state,\n    editorState: newEditorState,\n  };\n}\n\nfunction toggleBookmark(editorState: EditorState, zoomedInItemId: string) {\n  const { blockMap, contentState } = pluckGoodies(editorState);\n\n  const zoomedInBlock = blockMap.get(zoomedInItemId);\n\n  const newBlockMap = blockMap.set(\n    zoomedInItemId,\n    zoomedInBlock.setIn(\n      ['data', 'bookmarked'],\n      !zoomedInBlock.getIn(['data', 'bookmarked'])\n    ) as ContentBlock\n  ) as BlockMap;\n\n  return EditorState.push(\n    editorState,\n    contentState.set('blockMap', newBlockMap) as ContentState,\n    'bookmark' as any\n  );\n}\n\nexport function rootReducer(\n  state: DeepnotesEditorState,\n  action: EditorActions\n) {\n  switch (action.type) {\n    case CHANGE:\n      return {\n        ...state,\n        editorState: action.editorState,\n      };\n    case INSERT_SOFT_NEWLINE:\n      return {\n        ...state,\n        editorState: RichUtils.insertSoftNewline(state.editorState),\n      };\n    case SET_ROOT_EDITOR_STATE:\n      return {\n        ...state,\n        rootEditorState: action.editorState,\n      };\n    case SET_EDITOR_STATE:\n      return {\n        ...state,\n        editorState: action.editorState,\n      };\n    case SET_STATE:\n      return {\n        ...state,\n        [action.prop]: action.val,\n      };\n    case MOVE_UP:\n      return {\n        ...state,\n        editorState: moveCurrentBlockUp(\n          state.editorState,\n          state.zoomedInItemId\n        ),\n      };\n    case MOVE_DOWN:\n      return {\n        ...state,\n        editorState: moveCurrentBlockDown(\n          state.editorState,\n          state.zoomedInItemId\n        ),\n      };\n    case COLLAPSE_ITEM:\n      return {\n        ...state,\n        editorState: collapseBlock(state.editorState, action.blockKey),\n      };\n    case EXPAND_ITEM:\n      return {\n        ...state,\n        editorState: expandBlock(state.editorState, action.blockKey),\n      };\n    case EXPAND_ALL:\n      return expandCollapseAll(state, false);\n    case COLLAPSE_ALL:\n      return expandCollapseAll(state, true);\n    case TOGGLE_COMPLETION:\n      return toggleCompleteReducer(state);\n    case DELETE_CURRENT_ITEM:\n      return deleteItemWithChildren(state);\n    case ZOOM:\n      // TODO: we should always pluck out the id of the thing to zoom to\n      // and then send it to this reducer\n      return zoomReducer(state, action.blockKey);\n    case INDENT:\n      return {\n        ...state,\n        editorState: onTab(state.editorState, MAX_DEPTH, state.zoomedInItemId),\n      };\n    case DEDENT:\n      return {\n        ...state,\n        editorState: onTab(\n          state.editorState,\n          MAX_DEPTH,\n          state.zoomedInItemId,\n          true\n        ),\n      };\n    case BOOKMARK:\n      return {\n        ...state,\n        editorState: toggleBookmark(state.editorState, state.zoomedInItemId),\n      };\n    default:\n      return state;\n  }\n}\n","import * as React from 'react';\nimport classNames from 'classnames';\nimport {\n  DraftHandleValue,\n  ContentBlock,\n  Editor,\n  EditorState,\n  DraftEditorCommand,\n  RichUtils,\n  Modifier,\n  KeyBindingUtil,\n  getDefaultKeyBinding,\n} from 'draft-js';\n\nimport { EditorContext } from './EditorDispatchContext';\n\nimport debounce from '../../debounce';\nimport Menu from './Menu';\n// import { logToScreen } from './screen_logger';\nimport { createDecorators } from '../decorators';\nimport pluckGoodies from '../pluck_goodies';\nimport { getEmptySlateState } from '../block_creators';\nimport { addEmptyBlockToEnd } from '../add_empty_block_to_end';\nimport { getBlocksWithItsDescendants } from '../tree_utils';\nimport { splitBlock } from '../split_block';\nimport { findParent } from '../find_parent';\nimport { Item } from './Item';\nimport { pasteText } from '../paste_text';\nimport { ROOT_KEY, SEARCH_DEBOUNCE } from '../../constants';\nimport {\n  DeepnotesEditorState,\n  EditorActions,\n  rootReducer,\n  EXPAND_ALL,\n  COLLAPSE_ALL,\n} from '../state_manager';\nimport {\n  SET_ROOT_EDITOR_STATE,\n  SET_EDITOR_STATE,\n  INSERT_SOFT_NEWLINE,\n  ZOOM,\n  COLLAPSE_ITEM,\n  EXPAND_ITEM,\n  MOVE_UP,\n  MOVE_DOWN,\n  TOGGLE_COMPLETION,\n  DELETE_CURRENT_ITEM,\n  CHANGE,\n  INDENT,\n  DEDENT,\n  BOOKMARK,\n} from '../state_manager';\nimport useDocumentTitle from '../../hooks/document-title';\nimport usePrevious from '../../hooks/previous';\n\nimport { hasCollapsedAntecedent } from '../has_collapsed_antecedent';\nimport { sanitizePosAndDepthInfo } from '../sanitize_pos_and_depth_info';\n\nimport PlusSign from '../../icons/PlusSign';\n\nimport 'draft-js/dist/Draft.css';\nimport './editor_styles.global.css';\nimport buttonStyles from '../../button_styles.module.css';\nimport styles from './editor_styles.module.css';\n\ndeclare global {\n  interface Window {\n    state: DeepnotesEditorState;\n    scratch: any;\n  }\n}\n\nfunction notADescendantOfZoomedInItem(\n  editorState: EditorState,\n  block: ContentBlock,\n  zoomedInItemId: string\n) {\n  const { blockMap } = pluckGoodies(editorState);\n\n  const blockWithItsDescendants = getBlocksWithItsDescendants(\n    blockMap,\n    zoomedInItemId\n  );\n\n  return !blockWithItsDescendants.find(\n    (b?: ContentBlock) => !!(b && b.getKey() === block.getKey())\n  );\n}\n\n// This is the key to a faster blockShouldBeHidden function\n// TODO: Right now we are busting this cache on every render. We should find a way\n// to only bust it if required. That is, only bust it if there's an operation which might\n// spoil the data related to visibility.\nlet shouldBeHiddenCache: { [key: string]: boolean } = {};\nfunction blockShouldBeHidden(\n  editorState: EditorState,\n  block: ContentBlock,\n  zoomedInItemId: string,\n  searchText?: string\n) {\n  const { blockMap } = pluckGoodies(editorState);\n  const parentId = block.getIn(['data', 'parentId']);\n\n  if (shouldBeHiddenCache[parentId] !== undefined) {\n    // we set the hidden property of a zoomed in items parent also as hidden\n    // But we want to show the zoomed in item itself\n    return shouldBeHiddenCache[parentId] && block.getKey() !== zoomedInItemId;\n  }\n\n  const shouldBeHidden =\n    block.getKey() === ROOT_KEY ||\n    // When zoomed in, anything below the zoomed in item level can be hidden\n    block.getDepth() < blockMap.get(zoomedInItemId).getDepth() ||\n    (block.getKey() !== zoomedInItemId &&\n      // we don't want to hide items inside collapsed parents if there is a\n      // search text\n      !searchText &&\n      hasCollapsedAntecedent(blockMap, block.getKey(), zoomedInItemId)) ||\n    (searchText &&\n      !block\n        .getText()\n        .toLowerCase()\n        .includes(searchText.toLowerCase())) ||\n    notADescendantOfZoomedInItem(editorState, block, zoomedInItemId);\n\n  if (block.getKey() !== ROOT_KEY) {\n    shouldBeHiddenCache[parentId] = shouldBeHidden;\n    if (shouldBeHidden) {\n      shouldBeHiddenCache[block.getKey()] = shouldBeHidden;\n    }\n  }\n\n  return shouldBeHidden;\n}\n\nconst initialState = {\n  loading: true,\n  zoomedInItemId: ROOT_KEY,\n  rootEditorState: getEmptySlateState(ROOT_KEY),\n  editorState: getEmptySlateState(ROOT_KEY),\n};\n\ninterface Props {\n  initialEditorState?: EditorState;\n  initialZoomedInItemId: string;\n  searchText?: string;\n  onChange?: (editorState: EditorState) => void;\n  onRootChange?: (zoomedInItemId: string) => void;\n  editorWrapperStyle?: React.CSSProperties;\n  onBookmarkClick?: () => void;\n  withToolbar?: boolean;\n}\n\n// TODO: let's try to also retain the selection state here\n// Don't know if editor.getCurrentContent() has the selection state too. Should\n// have\nfunction forceUpdateEditorState(editorState: EditorState, searchText = '') {\n  // TODO - the below code ensures that our redo/undo stack is also maintained.\n  // But do we care about it when we zoom into an item?\n  const newEditorStateInstance = EditorState.createWithContent(\n    editorState.getCurrentContent(),\n    createDecorators(searchText)\n  );\n\n  return EditorState.set(newEditorStateInstance, {\n    selection: editorState.getSelection(),\n    undoStack: editorState.getUndoStack(),\n    redoStack: editorState.getRedoStack(),\n    lastChangeType: editorState.getLastChangeType(),\n  });\n}\n\n// Default maximum block depth supported by Draft.js CSS.\nexport const DRAFT_DEFAULT_MAX_DEPTH = 4;\n\n// Default depth class prefix from Draft.js CSS.\nexport const CUSTOM_DEPTH_CLASS = 'public-DraftStyleDefault-depth-deepnotes-';\n\nexport const generateListNestingStyles = (\n  selectorPrefix: string,\n  maxDepth: number\n) => {\n  let styles = `\n.public-DraftStyleDefault-unorderedListItem:empty {\n  display: none\n}\n`;\n\n  for (let depth = 0; depth <= maxDepth; depth++) {\n    const prefix = `${selectorPrefix}${depth}`;\n\n    styles += `\n.${prefix}.public-DraftStyleDefault-listLTR { \nlist-style: none;\npadding: 0;\nmargin: 0;\n}\n`;\n  }\n\n  return styles;\n};\n\n/**\n * Dynamically generates the right list nesting styles.\n * Can be wrapped as a pure component - to re-render only when `max` changes (eg. never).\n */\nexport const ListNestingStyles = React.memo((props: { max: number }) => {\n  const { max } = props;\n\n  return max > DRAFT_DEFAULT_MAX_DEPTH ? (\n    <style>{generateListNestingStyles(`${CUSTOM_DEPTH_CLASS}`, max)}</style>\n  ) : null;\n});\n\nListNestingStyles.displayName = 'ListNestingStyles';\n\n/**\n * Add depth classes that Draft.js doesn't provide.\n * See https://github.com/facebook/draft-js/blob/232791a4e92d94a52c869f853f9869367bdabdac/src/component/contents/DraftEditorContents-core.react.js#L58-L62.\n * @param {ContentBlock} block\n */\nexport const blockDepthStyleFn = (block: ContentBlock) => {\n  const type = block.getType();\n\n  if (type === 'unordered-list-item') {\n    const depth = block.getDepth();\n    const baseItemStyles = 'list-none m-0';\n    return `${baseItemStyles} ${CUSTOM_DEPTH_CLASS}${String(depth)}`;\n  }\n\n  return '';\n};\n\n// for caching the object containing dispatch related functions\n// otherwise the components accessing values from context rerender\n// on every render\nlet editorDispatchContextValue = {};\n\nfunction DeepnotesEditor(props: Props) {\n  // const [showBoardView, setShowBoardView] = React.useState(false);\n  const searchInputRef = React.useRef<HTMLInputElement>(null);\n  const editor = React.useRef<any>(null);\n  // using useReducer instead of multiple useState calls because this\n  // is the top component and will probably have the global state with it.\n  // useReducer will allow us to have logic to modify various parts of global\n  // state in one place\n  const [state, dispatch] = React.useReducer<\n    React.Reducer<DeepnotesEditorState, EditorActions>\n  >(\n    rootReducer,\n    // The second argument to useReducer can also be thought as the default\n    // value of the state. From reducer perspective, it means the initial\n    // value.\n    initialState\n  );\n\n  const {\n    searchText,\n    initialEditorState,\n    initialZoomedInItemId = ROOT_KEY,\n    onChange,\n    onRootChange,\n    editorWrapperStyle,\n    onBookmarkClick,\n    withToolbar = true,\n  } = props;\n  const { editorState, zoomedInItemId } = state;\n\n  window.state = state;\n\n  useDocumentTitle(editorState, zoomedInItemId);\n\n  function setRootEditorState(editorState: EditorState) {\n    dispatch({ type: SET_ROOT_EDITOR_STATE, editorState });\n  }\n\n  const setEditorState = React.useCallback(\n    (editorState: EditorState) => {\n      dispatch({ type: SET_EDITOR_STATE, editorState });\n    },\n    [dispatch]\n  );\n\n  const expandParticularBlock = React.useCallback(\n    (blockKey: string) => {\n      dispatch({ type: EXPAND_ITEM, blockKey });\n    },\n    [dispatch]\n  );\n\n  const collapseParticularBlock = React.useCallback(\n    (blockKey: string) => {\n      dispatch({ type: COLLAPSE_ITEM, blockKey });\n    },\n    [dispatch]\n  );\n\n  const zoomTo = React.useCallback(\n    (blockKey: string) => {\n      dispatch({ type: ZOOM, blockKey });\n\n      if (typeof onRootChange === 'function') {\n        onRootChange(blockKey);\n      }\n    },\n    [dispatch, onRootChange]\n  );\n\n  // load initial editorState from the owner props\n  // React.useEffect(() => {\n  // if (initialEditorState) {\n  // const sanitizedInitialEditorState = sanitizePosAndDepthInfo(\n  // initialEditorState,\n  // ROOT_KEY\n  // );\n  // setRootEditorState(sanitizedInitialEditorState);\n  // setEditorState(sanitizedInitialEditorState);\n  // }\n  // }, [initialEditorState, setEditorState]);\n\n  // load initial editorState from the owner props\n  React.useEffect(() => {\n    if (zoomedInItemId !== initialZoomedInItemId) {\n      zoomTo(initialZoomedInItemId);\n    }\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [zoomTo, initialZoomedInItemId]);\n\n  const updateEditorState = React.useCallback(\n    debounce((es: EditorState, searchText: string) => {\n      setEditorState(forceUpdateEditorState(es, searchText));\n    }, SEARCH_DEBOUNCE),\n    [setEditorState]\n  );\n\n  const previousSearchText = usePrevious(searchText);\n  React.useEffect(() => {\n    if (previousSearchText !== undefined && searchText !== previousSearchText) {\n      updateEditorState(editorState, searchText);\n    }\n\n    // i don't want to run it if previousSearchText changes\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [searchText]);\n\n  React.useEffect(() => {\n    if (typeof onChange === 'function') {\n      onChange(editorState);\n    }\n    // Nope. Just nope.\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [editorState]);\n\n  // better to store in state rather than calculating in every render\n  const baseDepth = editorState\n    .getCurrentContent()\n    .getBlockMap()\n    .get(zoomedInItemId)\n    .getDepth();\n\n  shouldBeHiddenCache = {};\n\n  function blockRendererFn(contentBlock: ContentBlock) {\n    const type = contentBlock.getType();\n\n    if (type === 'unordered-list-item') {\n      return {\n        component: Item,\n        editable: true,\n        // TODO: It would be better if we can remove the blockProps altogether\n        props: {\n          // TODO: Until we keep sending editorState to each Item, we can never memoize Item. editorState changes on every render.\n          // If we can pass attach `hidden` information on each block when we create them, we won't have to send this at all\n          zoomedInItemId: zoomedInItemId,\n          baseDepth,\n          searchText,\n          hidden: blockShouldBeHidden(\n            editorState,\n            contentBlock,\n            zoomedInItemId,\n            searchText\n          ),\n          onExpandClick: expandParticularBlock,\n          onCollapseClick: collapseParticularBlock,\n        },\n      };\n    }\n\n    return undefined;\n  }\n\n  function focusEditor() {\n    // We don't want to refocus if it's already in focus\n    if (\n      editor &&\n      editor.current &&\n      editor.current.editor !== document.activeElement\n    ) {\n      // when we are at root level, calling editor.current.focus() does not\n      // work. Because the selection on editorState is set to the first block\n      // by default\n      // because we have 2 blocks when we initialize the editor. One root\n      // block and another empty child block for the root. We do so in order\n      // to have a consistent representation of a tree at all zoom levels.\n      // But it breaks draft-js focus. So we have to manually focus the item\n      // by using DOM selection and rane magic.\n      // TODO: We can also try forcing selection to the 2nd block and setting the editorState in our state\n      // Update: Which is what we did. Had to do it in multiple places\n      // probably better to put a check in one place which says that if\n      // the selection is on the root block, move it to the first block\n      editor.current.focus();\n    } else {\n      console.log('Editor already in focus');\n    }\n  }\n\n  React.useEffect(() => {\n    setTimeout(() => {\n      focusEditor();\n    }, 100);\n\n    window.addEventListener('keydown', e => {\n      if (e && e.which === 27) {\n        // esc key\n        if (searchInputRef && searchInputRef.current) {\n          searchInputRef.current.focus();\n        }\n      }\n\n      if (\n        e.metaKey &&\n        e.which === 191 &&\n        editor.current &&\n        editor.current.editor !== document.activeElement\n      ) {\n        e.preventDefault();\n        e.stopPropagation();\n      }\n    });\n\n    if (initialEditorState) {\n      const sanitizedInitialEditorState = sanitizePosAndDepthInfo(\n        initialEditorState,\n        ROOT_KEY\n      );\n      setRootEditorState(sanitizedInitialEditorState);\n      setEditorState(sanitizedInitialEditorState);\n    }\n\n    // cleanup\n    return () => {\n      // TODO\n    };\n    // eslint-disable-next-line\n  }, []);\n\n  type SyntheticKeyboardEvent = React.KeyboardEvent<{}> | any;\n\n  // step 2. How do we have nested lists? When the user hits the tab key, we\n  // want the current list item to become a sub item to the outer one\n  // We can do that by using the onTab prop of the Editor\n  // And then creating new state using RichUtils.onTab helper function\n  // That function takes the current state, and increases the depth of the\n  // 'unordered-list-item' by 1\n  const handleTab = React.useCallback(\n    (event: SyntheticKeyboardEvent) => {\n      event.preventDefault();\n      if (event.shiftKey) {\n        dispatch({ type: DEDENT });\n      } else {\n        dispatch({ type: INDENT });\n      }\n    },\n    [dispatch]\n  );\n\n  const handleReturn = React.useCallback(\n    (event: SyntheticKeyboardEvent): DraftHandleValue => {\n      // alt+enter for marking item as complete. Works across platforms.\n      if (event.altKey) {\n        dispatch({ type: INSERT_SOFT_NEWLINE });\n        return 'handled';\n      }\n\n      return 'not-handled';\n    },\n    [dispatch]\n  );\n\n  function keyBindingFn(e: any): any {\n    if (\n      KeyBindingUtil.hasCommandModifier(e) ||\n      KeyBindingUtil.isCtrlKeyCommand(e)\n    ) {\n      switch (e.keyCode) {\n        case 191: // command+/\n          // we are handling this shortcut in Editor even though we don't control showing/hiding of keyboard shortcut panel in the editor\n          // draft-js has a default action of select-all for this shortcut\n          return 'toggle-keyboard-shortcut-panel';\n        case 38: // up arrow. Let's collapse the list\n          // cmd+shift+up moves the list item up\n          if (e.shiftKey) {\n            return 'move-up';\n          } else {\n            return 'collapse-list';\n          }\n        case 40: // down arrow\n          // cmd+shift+down moves the list item down\n          if (e.shiftKey) {\n            return 'move-down';\n          } else {\n            return 'expand-list';\n          }\n        case 190: // for Command+.\n          return 'zoom-in';\n        case 188: // for Command+,\n          return 'zoom-out';\n        case 13: // Command+enter\n          return 'toggle-completion';\n        case 222: // Command+'\n          return 'go-to-home';\n        case 8: // cmd+shift+backspace\n          if (e.shiftKey) {\n            return 'delete-item';\n          } else {\n            return getDefaultKeyBinding(e);\n          }\n        default:\n          return getDefaultKeyBinding(e);\n      }\n    } else {\n      if (e.keyCode === 9) {\n        return handleTab(e);\n      }\n    }\n\n    return getDefaultKeyBinding(e);\n  }\n\n  function zoomIn() {\n    const { anchorKey } = pluckGoodies(editorState);\n    zoomTo(anchorKey);\n  }\n\n  function zoomOut() {\n    // find the parent of the current zoomed in item, or nothing/root, if the\n    // item zoomed in is a first level list item, and then set correct url\n    const { editorState, zoomedInItemId } = state;\n\n    // if there is no zoomed item, that means there's nothing to zoom out into\n    // we are at the root\n    if (!zoomedInItemId) {\n      console.log('nothing is zoomed in so nothing to zoom out.');\n      return;\n    }\n\n    const parentBlockOfZoomedInBlock = findParent(editorState, zoomedInItemId);\n\n    if (parentBlockOfZoomedInBlock) {\n      zoomTo(parentBlockOfZoomedInBlock.getKey());\n    }\n  }\n\n  function collapse() {\n    const { anchorKey } = pluckGoodies(state.editorState);\n\n    if (anchorKey) {\n      dispatch({ type: COLLAPSE_ITEM, blockKey: anchorKey });\n    }\n  }\n\n  function expand() {\n    const { anchorKey } = pluckGoodies(state.editorState);\n\n    if (anchorKey) {\n      dispatch({ type: EXPAND_ITEM, blockKey: anchorKey });\n    }\n  }\n\n  const moveUp = React.useCallback(() => {\n    dispatch({ type: MOVE_UP });\n  }, [dispatch]);\n\n  const moveDown = React.useCallback(() => {\n    dispatch({ type: MOVE_DOWN });\n  }, [dispatch]);\n\n  const toggleCompletion = React.useCallback(() => {\n    dispatch({ type: TOGGLE_COMPLETION });\n  }, [dispatch]);\n\n  const goToHome = React.useCallback(() => {\n    window.location.hash = '';\n  }, []);\n\n  const deleteCurrentItem = React.useCallback(() => {\n    dispatch({ type: DELETE_CURRENT_ITEM });\n  }, [dispatch]);\n\n  type EditorCommand = DraftEditorCommand | string;\n  function handleKeyCommand(command: EditorCommand): DraftHandleValue {\n    switch (command) {\n      case 'move-up':\n        moveUp();\n        return 'handled';\n      case 'move-down':\n        moveDown();\n        return 'handled';\n      case 'collapse-list':\n        collapse();\n        return 'handled';\n      case 'expand-list':\n        expand();\n        return 'handled';\n      // this is called when user presses the Enter or Return key\n      case 'split-block':\n        // TODO: this causes a major bug when the block to split is collapsed\n        // The data inside the collapsed item vanishes\n        // Which means, we need to implement our own split block :()\n        // don't allow any new block creation when in search mode\n        if (!searchText) {\n          setEditorState(splitBlock(editorState, state.zoomedInItemId));\n        }\n        return 'handled';\n      case 'zoom-in':\n        zoomIn();\n        return 'handled';\n      case 'zoom-out':\n        zoomOut();\n        return 'handled';\n      case 'toggle-completion':\n        toggleCompletion();\n        return 'handled';\n      case 'backspace':\n        // eslint-disable-next-line no-case-declarations\n        const { contentState, blockMap, selectionState } = pluckGoodies(\n          state.editorState\n        );\n        // eslint-disable-next-line no-case-declarations\n        const block = blockMap.get(selectionState.getAnchorKey());\n\n        // if cursor is at the start of the list\n        if (block.getText() === '' || selectionState.getAnchorOffset() === 0) {\n          // 1. Don't allow deleting any non-leaf item this way. Causes other\n          // problems. It's consistent with how workflowy does it too.\n          // , don't do anything\n          // 2. also don't do anything when this item is the only item in the\n          // blockMap\n          // 3. also don't delete first item in the list - that item will not have\n          // any previous sibling\n          // 4. first item in zoomed in state - key same as zoomedInItemId\n          const pSibling = contentState.getBlockBefore(block.getKey());\n\n          if (\n            blockMap\n              .get(selectionState.getAnchorKey())\n              .getIn(['data', 'hasChildren']) ||\n            !pSibling ||\n            // accounting for every present ROOT block\n            blockMap.count() === 2 ||\n            block.getKey() === state.zoomedInItemId\n          ) {\n            return 'handled';\n          } else {\n            // else, delete the block\n            // even if this item has children, they will either become the\n            // previous siblings children or siblings\n            return 'not-handled';\n          }\n        } else {\n          return 'not-handled';\n        }\n      case 'go-to-home':\n        goToHome();\n        return 'handled';\n      case 'delete-item':\n        deleteCurrentItem();\n        return 'handled';\n      default:\n        // eslint-disable-next-line no-case-declarations\n        const newState = RichUtils.handleKeyCommand(editorState, command);\n\n        if (newState) {\n          setEditorState(newState);\n          return 'handled';\n        }\n\n        return 'not-handled';\n    }\n  }\n\n  function handleChange(editorState: EditorState) {\n    const { contentState, anchorBlock, selectionState } = pluckGoodies(\n      editorState\n    );\n\n    let newState = editorState;\n\n    // if somehow a change takes users out of list item type, force the block\n    // back to 'unordered-list-item' type\n    if (anchorBlock && anchorBlock.getType() !== 'unordered-list-item') {\n      const newContentState = Modifier.setBlockType(\n        contentState,\n        selectionState,\n        'unordered-list-item'\n      );\n      // TODO: What should be the change type here?\n      newState = EditorState.push(\n        editorState,\n        newContentState,\n        'force-list-type' as any\n      );\n    }\n\n    dispatch({ type: CHANGE, editorState: newState });\n  }\n\n  const handleIndentClick = React.useCallback(() => {\n    dispatch({ type: INDENT });\n  }, [dispatch]);\n\n  const handleOutdentClick = React.useCallback(() => {\n    dispatch({ type: DEDENT });\n  }, [dispatch]);\n\n  // TODO -\n  // Adding search brings in a lot of complexity. What happens when users\n  // searches something and then goes ahead and changes the filtered\n  // list of items\n  //    Ans - we can maintain a focus state for search input and only filter\n  //    blocks when the search input is in focus\n  // What happens if the search term is still there and user zooms out?\n  //    Ans - maybe we can clean the search text on zoom out\n  // When user searches something and then edits an item from the filtered\n  // list, draft-js onChange now sends back the filtered blocks in the\n  // changed editorState, which is what we store in our store. Which means\n  // we lose the unfiltered data once users start editing filtered data.\n  //    Ans - maintain another state variable called unfiltered data?\n  //    Or, instead of filtering the blocks and sending to draft-js editor,\n  //    just send the searchText to Item component and let it show/hide\n  //    that item based on the searchText. Yesssss.\n  // When user creates new item when in search mode. As soon as they type\n  // something in that block, it disappears because it doesn't match the\n  // search string. Can not let that happen by comparing the time stamps\n  // of last search input change and block update timestamp. If the block\n  // was created after the last search input was made, don't apply the\n  // search filter on it.\n\n  function handleAddNewItem() {\n    // add new item to the end of the list\n    // Make sure that it's at the end of the zoomed in list\n    dispatch({\n      type: SET_EDITOR_STATE,\n      editorState: addEmptyBlockToEnd(\n        state.editorState,\n        zoomedInItemId,\n        baseDepth + 1\n      ),\n    });\n  }\n\n  // TODO: if we move this to our reducer, we can then cache using React.useCallback((), [dispatch])\n  // set collapsed to false for every block\n  const handleExpandAllClick = React.useCallback(() => {\n    dispatch({ type: EXPAND_ALL });\n  }, [dispatch]);\n\n  // keep calling collapseBlock for all the blocks\n  // works like a charm\n  const handleCollapseAllClick = React.useCallback(() => {\n    dispatch({ type: COLLAPSE_ALL });\n  }, [dispatch]);\n\n  // For times when user tabs through rest of the elements in our page\n  // The editor itself will also be focusable\n  function handleWrapperFocus() {\n    focusEditor();\n  }\n\n  function handlePastedText(pastedText: string) {\n    setEditorState(pasteText(editorState, pastedText));\n    return 'handled' as DraftHandleValue;\n  }\n\n  // function handleshowboardviewclick() {\n  //   if (zoomedInItemId !== ROOT_KEY) {\n  //     console.log('board view activated');\n  //     setShowBoardView(!showBoardView);\n  //   } else {\n  //     alert('Cannot show board view at root level');\n  //   }\n  // }\n\n  // This is to cache the object we set as value for EditorDispatchContext\n  // If we don't do this, we create a new object on every render\n  // Which then rerenders every component accessing anything from the\n  // EditorDispatchContext\n  React.useEffect(() => {\n    editorDispatchContextValue = {\n      onZoom: zoomTo,\n      onExpandClick: expandParticularBlock,\n      onCollapseClick: collapseParticularBlock,\n    };\n  }, [zoomTo, expandParticularBlock, collapseParticularBlock]);\n\n  const handleBookmarkClick = React.useCallback(() => {\n    dispatch({ type: BOOKMARK });\n\n    if (typeof onBookmarkClick === 'function') {\n      onBookmarkClick();\n    }\n  }, [dispatch, onBookmarkClick]);\n\n  // className=\"flex flex-col w-full p-10 pt-3 pl-6 mb-12 sm:pl-10 sm:shadow-sm rounded-md\"\n  return (\n    <div className=\"editor deepnotes-editor-theme-light\">\n      {withToolbar && (\n        <Menu\n          onExpandAllClick={handleExpandAllClick}\n          onCollapseAllClick={handleCollapseAllClick}\n          onIndentClick={handleIndentClick}\n          onOutdentClick={handleOutdentClick}\n          onToggleCompletionClick={toggleCompletion}\n          isBookmarked={\n            editorState &&\n            !!editorState\n              .getCurrentContent()\n              .getBlockMap()\n              .get(zoomedInItemId)\n              .getIn(['data', 'bookmarked'])\n          }\n          onBookmarkClick={handleBookmarkClick}\n        />\n      )}\n      <div\n        className={styles.container}\n        tabIndex={0}\n        onFocus={handleWrapperFocus}\n        style={{ minHeight: 300, ...editorWrapperStyle }}\n      >\n        <EditorContext.Provider value={editorDispatchContextValue}>\n          <Editor\n            webDriverTestID=\"dumpster-editor\"\n            textAlignment=\"left\"\n            ref={editor}\n            editorState={editorState}\n            onChange={handleChange}\n            blockRendererFn={blockRendererFn}\n            handleReturn={handleReturn}\n            handlePastedText={handlePastedText}\n            stripPastedStyles={true}\n            keyBindingFn={keyBindingFn}\n            handleKeyCommand={handleKeyCommand}\n            onFocus={() => console.log('editor got focus')}\n            placeholder=\"Start writing\"\n            blockStyleFn={blockDepthStyleFn}\n            customStyleMap={{\n              CODE: {\n                color: '#15141f',\n                background: '#eae9ed',\n                fontFamily:\n                  'Monaco,Menlo,Ubuntu Mono,Droid Sans Mono,Consolas,monospace',\n                fontSize: '0.9em',\n                padding: '0 0.25rem',\n                margin: '0 0.0625rem',\n                borderRadius: '0.125rem',\n                overflowWrap: 'break-word',\n                wordWrap: 'break-word',\n              },\n            }}\n          />\n          <ListNestingStyles max={40} />\n        </EditorContext.Provider>\n        <button\n          className={classNames(\n            buttonStyles['button'],\n            buttonStyles['icon-button'],\n            styles['new-item-button']\n          )}\n          onClick={handleAddNewItem}\n          aria-label=\"Add new item\"\n          title=\"Add new item\"\n        >\n          <PlusSign\n            className={styles['new-item-icon']}\n            aria-label=\"Add new item\"\n          />\n        </button>\n      </div>\n    </div>\n  );\n}\n\nexport default React.memo(DeepnotesEditor);\n","import { BlockMap } from 'draft-js';\n\n/**\n * Find if parent or grandparent or some other ancestor in the tree is collapsed\n */\nexport function hasCollapsedAntecedent(\n  blockMap: BlockMap,\n  blockKey: string,\n  zoomedInItemId?: string\n) {\n  const collapsed = false;\n\n  const block = blockMap.get(blockKey);\n\n  if (!block) {\n    return collapsed;\n  }\n\n  let parentBlock = blockMap.get(block.getIn(['data', 'parentId']));\n\n  while (parentBlock) {\n    if (zoomedInItemId && parentBlock.getKey() === zoomedInItemId) {\n      break;\n    }\n\n    if (parentBlock.getIn(['data', 'collapsed'])) {\n      return true;\n    }\n\n    parentBlock = blockMap.get(parentBlock.getIn(['data', 'parentId']));\n  }\n\n  return collapsed;\n}\n","import * as React from 'react';\nimport { EditorState } from 'draft-js';\n\nimport { ROOT_KEY } from '../constants';\n\nexport default function useDocumentTitle(\n  editorState: EditorState,\n  zoomedInItemId: string\n) {\n  const rootDocumentTitle = 'deepnotes - Note taking made easy. And deep.';\n\n  React.useEffect(() => {\n    if (zoomedInItemId === ROOT_KEY) {\n      document.title = rootDocumentTitle;\n    } else {\n      const blockMap = editorState.getCurrentContent().getBlockMap();\n      const zoomedInItemText = blockMap.get(zoomedInItemId).getText();\n\n      document.title = zoomedInItemText;\n    }\n  }, [editorState, zoomedInItemId]);\n}\n","export default function debounce(fn: Function, delay: number) {\n  let setTimeoutHandle: any;\n\n  return function(...args: Array<any>) {\n    // if the function is called again, cancel the timeout and start over again\n    clearTimeout(setTimeoutHandle);\n    setTimeoutHandle = setTimeout(() => {\n      fn.apply(null, args);\n    }, delay);\n  };\n}\n","import * as React from 'react';\n\n// Hooks which stores the previous state value so that we can compare the\n// current and previous values. Like we do in componentDidUpdate with\n// prevProps\nexport default function usePrevious<T>(value?: T): T | undefined {\n  // The ref object is a generic container whose current property is mutable ...\n  // ... and can hold any value, similar to an instance property on a class\n  const ref = React.useRef<T | undefined>(undefined);\n\n  // Store current value in ref\n  React.useEffect(() => {\n    ref.current = value;\n  }, [value]); // Only re-run if value changes\n\n  // Return previous value (happens before update in useEffect above)\n  return ref.current;\n}\n","import {\n  ContentBlock,\n  BlockMap,\n  EditorState,\n  ContentState,\n  SelectionState,\n} from 'draft-js';\n\nimport { ROOT_KEY } from '../constants';\n\nimport pluckGoodies from './pluck_goodies';\nimport { getPosNum } from './pos_generators';\nimport { getEmptySlateState } from './block_creators';\nimport { createDecorators } from './decorators';\nimport { hasChildren } from './tree_utils';\n\nfunction blocksWithSanitizedPosAndDepthAndHasChildren(\n  blockMap: BlockMap,\n  node: ContentBlock\n): Array<ContentBlock> {\n  const nodeKey = node.getKey();\n  const nodeDepth = node.getDepth();\n\n  const children = blockMap\n    .filter(b => !!(b && b.getIn(['data', 'parentId']) === nodeKey))\n    .toArray()\n    .map((block, index) => {\n      return block\n        .setIn(['data', 'pos'], getPosNum(index + 1))\n        .setIn(['data', 'hasChildren'], hasChildren(blockMap, block.getKey()))\n        .set('depth', nodeDepth + 1);\n    }) as Array<ContentBlock>;\n\n  if (!children) {\n    return [node];\n  }\n\n  return [node].concat(\n    children\n      .map((child: ContentBlock) =>\n        blocksWithSanitizedPosAndDepthAndHasChildren(blockMap, child)\n      )\n      .flat()\n  );\n}\n\n/**\n * We have wrong pos information stored in the blocks some times. Don't know the root cause.\n * It causes many operations to behave in the wrong way. E.g. Dedent a child of an item with wrong pos causes the child item to move in an unpredictable manner.\n * move-up and move-down also start working weirdly.\n * So we sanitize or correct the pos information before we render anything.\n * The next time this data is saved, it's alright.\n * @param editorState\n */\nexport function sanitizePosAndDepthInfo(\n  editorState: EditorState,\n  rootKey: string\n) {\n  const { blockMap } = pluckGoodies(editorState);\n\n  if (!blockMap || blockMap.count() < 1) {\n    return getEmptySlateState(ROOT_KEY);\n  }\n\n  const blocks = blocksWithSanitizedPosAndDepthAndHasChildren(\n    blockMap,\n    blockMap.get(rootKey)\n  );\n\n  const newEditorState = EditorState.createWithContent(\n    ContentState.createFromBlockArray(blocks),\n    createDecorators()\n  );\n  let selection;\n  if (blocks.length > 1) {\n    selection = SelectionState.createEmpty(blocks[1].getKey());\n  } else if (blocks.length > 0) {\n    selection = SelectionState.createEmpty(blocks[0].getKey());\n  } else {\n    return newEditorState;\n  }\n\n  return EditorState.forceSelection(newEditorState, selection);\n}\n","import { EditorState, Modifier } from 'draft-js';\nimport pluckGoodies from './pluck_goodies';\n\nexport function pasteText(\n  editorState: EditorState,\n  pastedText: string\n): EditorState {\n  const { contentState, selectionState } = pluckGoodies(editorState);\n\n  return EditorState.push(\n    editorState,\n    Modifier.replaceText(contentState, selectionState, pastedText),\n    'paste-text' as any\n  );\n}\n","import { EditorState, ContentState, ContentBlock } from 'draft-js';\n\nimport { getPosNum, getPosInBetween, getPosAfter } from './pos_generators';\nimport pluckGoodies from './pluck_goodies';\nimport { getChildren, hasChildren, getNextSibling } from './tree_utils';\nimport { getNewContentBlock } from './block_creators';\nimport { recreateParentBlockMap } from './recreate_parent_block_map';\n\n// TODO: add parentKey to the newly created blocks\n// TODO: add order to the newly created blocks\n// TODO: Write unit tests for this function\n// TODO: Adjust the hasChildren attribute of both the newly created block as well as their\n// parent blocks, in case the newly created block becomes a child of some block\nexport function splitBlock(editorState: EditorState, zoomedInItemId: string) {\n  const { contentState, selectionState, blockMap } = pluckGoodies(editorState);\n\n  // only allow split block when nothing is selected\n  if (!selectionState.isCollapsed()) {\n    return editorState;\n  }\n\n  const key = selectionState.getAnchorKey();\n  let blockToSplit = blockMap.get(key);\n  const text = blockToSplit.getText();\n  const isBlockCollapsed = blockToSplit.getIn(['data', 'collapsed']);\n  const isBlockToSplitZoomedIn = zoomedInItemId === blockToSplit.getKey();\n\n  let offset = selectionState.getAnchorOffset();\n  // if we calculate offset, pos and parentId, we are good to go.\n  // we can set the new text on the split block and create a\n  // new block with parentId and pos and recreateParentBlock\n  let pos, parentId;\n  const chars = blockToSplit.getCharacterList();\n\n  // if user presses enter when cursor is at the start of line of a zoomed in\n  // item, we want to create a new empty child item instead of pushing the whole\n  // line of zoomed in item to the child\n  if (isBlockToSplitZoomedIn && offset === 0) {\n    offset = blockToSplit.getText().length;\n  }\n\n  // if the block to split is the zoomed in item, we need to add the new item\n  // as a child, i.e. depth greater than the block being split\n  // We also want to do that for all kinds of parent items when they are not collapsed\n  // Every zoomed in item is a parent and we might want to remove that condition altogether\n  // but that will not work since a zoomed in item might be collapsed\n  if (\n    isBlockToSplitZoomedIn ||\n    (!isBlockCollapsed &&\n      hasChildren(blockMap, blockToSplit.getKey()) &&\n      // we don't want to create a new child if the split is with cursor at the beginning\n      // of the line. Then just create a new block above the current block\n      selectionState.getStartOffset() !== 0)\n  ) {\n    // the child can either be the first child EVER of the item\n\n    // or one of the chlidren. In the second case, we need to calculate the pos carefully\n    const zoomedInBlockChildren = getChildren(blockMap, blockToSplit.getKey());\n    if (zoomedInBlockChildren.count() > 0) {\n      pos = getPosInBetween(\n        0,\n        zoomedInBlockChildren.first().getIn(['data', 'pos'])\n      );\n    } else {\n      pos = getPosNum(1);\n    }\n    parentId = blockToSplit.getKey();\n  } else {\n    const nextSibling = getNextSibling(blockMap, blockToSplit.getKey());\n\n    if (nextSibling) {\n      pos = getPosInBetween(\n        blockToSplit.get('data').get('pos'),\n        nextSibling.get('data').get('pos')\n      );\n    } else {\n      pos = getPosAfter(blockToSplit.getIn(['data', 'pos']));\n    }\n\n    parentId = blockToSplit.getIn(['data', 'parentId']);\n    // if we are inserting a block above current block by keeping cursor at beginning of line and pressing enter\n    if (selectionState.getStartOffset() === 0) {\n      const tempPos = blockToSplit.getIn(['data', 'pos']);\n      blockToSplit = blockToSplit.setIn(['data', 'pos'], pos) as ContentBlock;\n      pos = tempPos;\n\n      offset = blockToSplit.getText().length;\n    }\n  }\n\n  let newBlockMap = blockMap.set(\n    blockToSplit.getKey(),\n    blockToSplit\n      .set('text', text.slice(0, offset))\n      .set('characterList', chars.slice(0, offset)) as ContentBlock\n  ) as ContentBlock;\n  const newBlock = getNewContentBlock({\n    text: text.slice(offset),\n  })\n    .set('depth', blockMap.get(parentId).getDepth() + 1)\n    .setIn(['data', 'parentId'], parentId)\n    .setIn(['data', 'pos'], pos) as ContentBlock;\n  newBlockMap = newBlockMap.set(newBlock.getKey(), newBlock) as ContentBlock;\n  newBlockMap = recreateParentBlockMap(\n    contentState.merge({\n      blockMap: newBlockMap,\n    }) as ContentState,\n    newBlockMap,\n    parentId\n  ) as ContentBlock;\n\n  const newContentState = contentState.merge({\n    blockMap: newBlockMap,\n    selectionBefore: selectionState,\n    selectionAfter: selectionState.merge({\n      anchorKey: newBlock.getKey(),\n      anchorOffset: 0,\n      focusKey: newBlock.getKey(),\n      focusOffset: 0,\n      isBackward: false,\n    }),\n  }) as ContentState;\n\n  // Always, always use this method to modify editorState when in doubt about\n  // how to edit the editor state. It maintains the undo/redo stack for the\n  // stack - https://draftjs.org/docs/api-reference-editor-state#push\n  return EditorState.push(editorState, newContentState, 'split-block');\n}\n"],"names":["EditorContext","React","CheckMark","props","fill","strokeLinecap","strokeLinejoin","strokeWidth","viewBox","stroke","d","ArrowRight","ArrowLeft","DotHorizontal","Star","MenuContainer","onExpandAllClick","onCollapseAllClick","onIndentClick","onOutdentClick","onToggleCompletionClick","isBookmarked","onBookmarkClick","className","onMouseDown","e","stopPropagation","preventDefault","nativeEvent","stopImmediatePropagation","classNames","buttonStyles","title","styles","style","marginRight","Menu","MenuButton","MenuList","MenuItem","onSelect","Hashtag","children","handleSearchInputChange","textDecoration","color","cursor","onClick","text","SearchHighlight","background","Link","link","map","child","join","href","window","open","linkifyInstance","linkify","HASHTAG_REGEX","findWithRegex","regex","contentBlock","callback","getText","matchArr","start","exec","index","length","hashtagStrategy","findLinkEntities","links","match","forEach","lastIndex","createDecorators","memoizeOne","searchText","RegExp","escapeStringRegexp","CompositeDecorator","strategy","component","pluckGoodies","editorState","contentState","getCurrentContent","selectionState","getSelection","blockMap","getBlockMap","anchorKey","getAnchorKey","anchorBlock","getBlockForKey","focusKey","getFocusKey","focusBlock","ROOT_KEY","getPosNum","pos","getPosInBetween","posStart","posEnd","Math","round","getPosAfter","lastPos","getNewContentBlock","config","ContentBlock","key","genKey","type","depth","getEmptySlateState","rootId","firstItem","set","Immutable","Map","parentId","rootBlock","getRootBlock","emptySlate","EditorState","createWithContent","ContentState","createFromBlockArray","forceSelection","SelectionState","createEmpty","getKey","calculateDepth","blockKey","zoomedInItemId","block","get","parentBlock","getIn","hasChildren","find","b","adjustHasChildren","setIn","getChildren","filter","getNextSibling","getPreviousSibling","reverse","getBlocksWithItsDescendants","toSeq","skipUntil","_","k","takeWhile","addEmptyBlockToEnd","newBlock","newBlockMap","parentBlockKey","blockToAdd","blockWithItsChildren","blockToInsertAfterKey","count","last","blocks","insertionBlockKey","blocksToInsert","insertBefore","insertionBlock","blocksBeforeInsertionPoint","takeUntil","blocksAfterInsertionPoint","rest","concat","toOrderedMap","insertBlocksAtKey","insertBlocksAfter","OrderedMap","appendChild","newSelection","newContentState","merge","selectionBefore","selectionAfter","anchorOffset","focusOffset","push","recreateParentBlockMap","startKey","endKey","startBlockKey","first","getStartAndEndKeys","startIndex","keySeq","findIndex","endIndex","recreatedBlocks","makeCorrectionsToNodeAndItsDescendants","node","nodeDepth","getDepth","nodeKey","arr","newArr","sort","item1","item2","sortByPos","toArray","flat","slice","findParent","skipWhile","DownArrow","xmlns","Disc","collapsed","itemId","isCollapsible","onZoom","onExpandClick","onCollapseClick","marginTop","width","height","contentEditable","cx","cy","r","PlusSign","version","id","xmlnsXlink","x","y","enableBackground","xmlSpace","MinusSign","areEqual","prevProps","newProps","prevBlock","blockProps","hidden","prevHidden","baseDepth","prevBaseDepth","prevSearchText","nextBlock","nextHidden","nextBaseDepth","nextSearchText","Item","completed","collapsible","itemClasses","wrapInNestedDivs","el","marginLeft","EditorBlock","moveBlock","blockToSwapWith","blockToMoveKey","newParentId","newPos","moveCurrentBlockUp","previousSibling","parent","parentsPreviousSibling","getBlockToInsertBefore","console","log","getBlockAfter","getAnchorOffset","getFocusOffset","newState","moveCurrentBlockDown","nextSibling","getBlockToInsertAfter","firstChild","getFirstChild","toggleCollapseState","collapseState","undefined","collapseBlock","expandBlock","onTab","maxDepth","shiftKey","selection","getStartKey","content","startBlock","previousBlock","getBlockBefore","withAdjustment","adjustment","indentBlockKey","indentBlock","newDepth","oldParentId","getParentIdAfterAdjustment","adjustedBlockKey","blocksWithSameParent","blockBefore","blockAfter","i","getPosAfterAdjustment","adjustBlockDepthForContentState","updateSelectionForZoom","newSelectionState","expandCollapseAll","state","collapse","blocksWithItsDescendants","newEditorState","toggleBookmark","zoomedInBlock","rootReducer","action","RichUtils","insertSoftNewline","rootEditorState","prop","val","trim","toggleCompleteReducer","blocksToDelete","has","pSibling","deleteItemWithChildren","zoomedBlock","newZoomedInItemId","zoomReducer","displayName","shouldBeHiddenCache","blockShouldBeHidden","shouldBeHidden","hasCollapsedAntecedent","toLowerCase","includes","notADescendantOfZoomedInItem","initialState","loading","ListNestingStyles","max","selectorPrefix","generateListNestingStyles","blockDepthStyleFn","getType","String","editorDispatchContextValue","DeepnotesEditor","searchInputRef","editor","dispatch","initialEditorState","initialZoomedInItemId","onChange","onRootChange","editorWrapperStyle","withToolbar","document","zoomedInItemText","useDocumentTitle","setEditorState","expandParticularBlock","collapseParticularBlock","zoomTo","updateEditorState","fn","delay","setTimeoutHandle","args","clearTimeout","setTimeout","apply","debounce","es","newEditorStateInstance","undoStack","getUndoStack","redoStack","getRedoStack","lastChangeType","getLastChangeType","forceUpdateEditorState","previousSearchText","value","ref","current","usePrevious","focusEditor","activeElement","focus","addEventListener","which","metaKey","sanitizedInitialEditorState","rootKey","blocksWithSanitizedPosAndDepthAndHasChildren","sanitizePosAndDepthInfo","setRootEditorState","handleTab","event","handleReturn","altKey","moveUp","moveDown","toggleCompletion","goToHome","location","hash","deleteCurrentItem","handleIndentClick","handleOutdentClick","handleExpandAllClick","handleCollapseAllClick","handleBookmarkClick","tabIndex","onFocus","minHeight","Provider","Editor","webDriverTestID","textAlignment","Modifier","setBlockType","blockRendererFn","editable","handlePastedText","pastedText","replaceText","pasteText","stripPastedStyles","keyBindingFn","KeyBindingUtil","hasCommandModifier","isCtrlKeyCommand","keyCode","getDefaultKeyBinding","handleKeyCommand","command","expand","isCollapsed","blockToSplit","isBlockCollapsed","isBlockToSplitZoomedIn","offset","chars","getCharacterList","getStartOffset","zoomedInBlockChildren","tempPos","isBackward","splitBlock","zoomIn","parentBlockOfZoomedInBlock","zoomOut","placeholder","blockStyleFn","customStyleMap","CODE","fontFamily","fontSize","padding","margin","borderRadius","overflowWrap","wordWrap"],"mappings":"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"}